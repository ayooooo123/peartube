// This file is autogenerated by the hyperschema compiler
// Schema Version: 7
/* eslint-disable camelcase */
/* eslint-disable quotes */
/* eslint-disable space-before-function-paren */

const { c } = require('hyperschema/runtime')

const VERSION = 7

// eslint-disable-next-line no-unused-vars
let version = VERSION

// @peartube/empty
const encoding0 = {
  preencode(state, m) {

  },
  encode(state, m) {

  },
  decode(state) {
    return {
    }
  }
}

// @peartube/error
const encoding1 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.code) c.uint.preencode(state, m.code)
    c.string.preencode(state, m.message)
  },
  encode(state, m) {
    const flags = m.code ? 1 : 0

    c.uint.encode(state, flags)

    if (m.code) c.uint.encode(state, m.code)
    c.string.encode(state, m.message)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      code: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      message: c.string.decode(state)
    }
  }
}

// @peartube/identity
const encoding2 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
    state.end++ // max flag is 32 so always one byte

    if (m.driveKey) c.string.preencode(state, m.driveKey)
    if (m.name) c.string.preencode(state, m.name)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.seedPhrase) c.string.preencode(state, m.seedPhrase)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
  },
  encode(state, m) {
    const flags =
      (m.driveKey ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.avatar ? 4 : 0) |
      (m.seedPhrase ? 8 : 0) |
      (m.createdAt ? 16 : 0) |
      (m.isActive ? 32 : 0)

    c.string.encode(state, m.publicKey)
    c.uint.encode(state, flags)

    if (m.driveKey) c.string.encode(state, m.driveKey)
    if (m.name) c.string.encode(state, m.name)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.seedPhrase) c.string.encode(state, m.seedPhrase)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      publicKey: r0,
      driveKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null,
      seedPhrase: (flags & 8) !== 0 ? c.string.decode(state) : null,
      createdAt: (flags & 16) !== 0 ? c.uint.decode(state) : 0,
      isActive: (flags & 32) !== 0
    }
  }
}

// @peartube/create-identity-request
const encoding3 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.avatar) c.string.preencode(state, m.avatar)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.avatar ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.avatar) c.string.encode(state, m.avatar)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/create-identity-response.identity
const encoding4_0 = c.frame(encoding2)

// @peartube/create-identity-response
const encoding4 = {
  preencode(state, m) {
    encoding4_0.preencode(state, m.identity)
  },
  encode(state, m) {
    encoding4_0.encode(state, m.identity)
  },
  decode(state) {
    const r0 = encoding4_0.decode(state)

    return {
      identity: r0
    }
  }
}

// @peartube/get-identity-request
const encoding5 = encoding0

// @peartube/get-identity-response.identity
const encoding6_0 = encoding4_0

// @peartube/get-identity-response
const encoding6 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.identity) encoding6_0.preencode(state, m.identity)
  },
  encode(state, m) {
    const flags = m.identity ? 1 : 0

    c.uint.encode(state, flags)

    if (m.identity) encoding6_0.encode(state, m.identity)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      identity: (flags & 1) !== 0 ? encoding6_0.decode(state) : null
    }
  }
}

// @peartube/get-identities-request
const encoding7 = encoding0

// @peartube/get-identities-response.identities
const encoding8_0 = c.array(c.frame(encoding2))

// @peartube/get-identities-response
const encoding8 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.identities) encoding8_0.preencode(state, m.identities)
  },
  encode(state, m) {
    const flags = m.identities ? 1 : 0

    c.uint.encode(state, flags)

    if (m.identities) encoding8_0.encode(state, m.identities)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      identities: (flags & 1) !== 0 ? encoding8_0.decode(state) : null
    }
  }
}

// @peartube/set-active-identity-request
const encoding9 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
  },
  encode(state, m) {
    c.string.encode(state, m.publicKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      publicKey: r0
    }
  }
}

// @peartube/set-active-identity-response
const encoding10 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = m.success ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0
    }
  }
}

// @peartube/recover-identity-request
const encoding11 = {
  preencode(state, m) {
    c.string.preencode(state, m.seedPhrase)
  },
  encode(state, m) {
    c.string.encode(state, m.seedPhrase)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      seedPhrase: r0
    }
  }
}

// @peartube/recover-identity-response.identity
const encoding12_0 = encoding4_0

// @peartube/recover-identity-response
const encoding12 = {
  preencode(state, m) {
    encoding12_0.preencode(state, m.identity)
  },
  encode(state, m) {
    encoding12_0.encode(state, m.identity)
  },
  decode(state) {
    const r0 = encoding12_0.decode(state)

    return {
      identity: r0
    }
  }
}

// @peartube/channel
const encoding13 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
    state.end++ // max flag is 16 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
    if (m.subscriberCount) c.uint.preencode(state, m.subscriberCount)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.avatar ? 4 : 0) |
      (m.videoCount ? 8 : 0) |
      (m.subscriberCount ? 16 : 0)

    c.string.encode(state, m.publicKey)
    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
    if (m.subscriberCount) c.uint.encode(state, m.subscriberCount)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      publicKey: r0,
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      subscriberCount: (flags & 16) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-channel-request
const encoding14 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.publicKey) c.string.preencode(state, m.publicKey)
  },
  encode(state, m) {
    const flags = m.publicKey ? 1 : 0

    c.uint.encode(state, flags)

    if (m.publicKey) c.string.encode(state, m.publicKey)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      publicKey: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-channel-response.channel
const encoding15_0 = c.frame(encoding13)

// @peartube/get-channel-response
const encoding15 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.channel) encoding15_0.preencode(state, m.channel)
  },
  encode(state, m) {
    const flags = m.channel ? 1 : 0

    c.uint.encode(state, flags)

    if (m.channel) encoding15_0.encode(state, m.channel)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channel: (flags & 1) !== 0 ? encoding15_0.decode(state) : null
    }
  }
}

// @peartube/update-channel-request
const encoding16 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.avatar) c.string.preencode(state, m.avatar)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.avatar ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.avatar) c.string.encode(state, m.avatar)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/update-channel-response.channel
const encoding17_0 = encoding15_0

// @peartube/update-channel-response
const encoding17 = {
  preencode(state, m) {
    encoding17_0.preencode(state, m.channel)
  },
  encode(state, m) {
    encoding17_0.encode(state, m.channel)
  },
  decode(state) {
    const r0 = encoding17_0.decode(state)

    return {
      channel: r0
    }
  }
}

// @peartube/video
const encoding18 = {
  preencode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.path ? 2 : 0) |
      (m.duration ? 4 : 0) |
      (m.thumbnail ? 8 : 0) |
      (m.channelKey ? 16 : 0) |
      (m.channelName ? 32 : 0) |
      (m.createdAt ? 64 : 0) |
      (m.views ? 128 : 0) |
      (m.category ? 256 : 0)

    c.string.preencode(state, m.id)
    c.string.preencode(state, m.title)
    c.uint.preencode(state, flags)

    if (m.description) c.string.preencode(state, m.description)
    if (m.path) c.string.preencode(state, m.path)
    if (m.duration) c.uint.preencode(state, m.duration)
    if (m.thumbnail) c.string.preencode(state, m.thumbnail)
    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
    if (m.views) c.uint.preencode(state, m.views)
    if (m.category) c.string.preencode(state, m.category)
  },
  encode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.path ? 2 : 0) |
      (m.duration ? 4 : 0) |
      (m.thumbnail ? 8 : 0) |
      (m.channelKey ? 16 : 0) |
      (m.channelName ? 32 : 0) |
      (m.createdAt ? 64 : 0) |
      (m.views ? 128 : 0) |
      (m.category ? 256 : 0)

    c.string.encode(state, m.id)
    c.string.encode(state, m.title)
    c.uint.encode(state, flags)

    if (m.description) c.string.encode(state, m.description)
    if (m.path) c.string.encode(state, m.path)
    if (m.duration) c.uint.encode(state, m.duration)
    if (m.thumbnail) c.string.encode(state, m.thumbnail)
    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
    if (m.views) c.uint.encode(state, m.views)
    if (m.category) c.string.encode(state, m.category)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      id: r0,
      title: r1,
      description: (flags & 1) !== 0 ? c.string.decode(state) : null,
      path: (flags & 2) !== 0 ? c.string.decode(state) : null,
      duration: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      thumbnail: (flags & 8) !== 0 ? c.string.decode(state) : null,
      channelKey: (flags & 16) !== 0 ? c.string.decode(state) : null,
      channelName: (flags & 32) !== 0 ? c.string.decode(state) : null,
      createdAt: (flags & 64) !== 0 ? c.uint.decode(state) : 0,
      views: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      category: (flags & 256) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/list-videos-request
const encoding19 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.limit) c.uint.preencode(state, m.limit)
    if (m.offset) c.uint.preencode(state, m.offset)
  },
  encode(state, m) {
    const flags =
      (m.channelKey ? 1 : 0) |
      (m.limit ? 2 : 0) |
      (m.offset ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.limit) c.uint.encode(state, m.limit)
    if (m.offset) c.uint.encode(state, m.offset)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channelKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      limit: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      offset: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/list-videos-response.videos
const encoding20_0 = c.array(c.frame(encoding18))

// @peartube/list-videos-response
const encoding20 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.videos) encoding20_0.preencode(state, m.videos)
  },
  encode(state, m) {
    const flags = m.videos ? 1 : 0

    c.uint.encode(state, flags)

    if (m.videos) encoding20_0.encode(state, m.videos)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      videos: (flags & 1) !== 0 ? encoding20_0.decode(state) : null
    }
  }
}

// @peartube/get-video-url-request
const encoding21 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      channelKey: r0,
      videoId: r1
    }
  }
}

// @peartube/get-video-url-response
const encoding22 = {
  preencode(state, m) {
    c.string.preencode(state, m.url)
  },
  encode(state, m) {
    c.string.encode(state, m.url)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      url: r0
    }
  }
}

// @peartube/get-video-data-request
const encoding23 = encoding21

// @peartube/get-video-data-response.video
const encoding24_0 = c.frame(encoding18)

// @peartube/get-video-data-response
const encoding24 = {
  preencode(state, m) {
    encoding24_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding24_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding24_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/upload-video-request
const encoding25 = {
  preencode(state, m) {
    c.string.preencode(state, m.filePath)
    c.string.preencode(state, m.title)
    state.end++ // max flag is 4 so always one byte

    if (m.description) c.string.preencode(state, m.description)
    if (m.category) c.string.preencode(state, m.category)
  },
  encode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.category ? 2 : 0) |
      ((version >= 3 && m.skipThumbnailGeneration) ? 4 : 0)

    c.string.encode(state, m.filePath)
    c.string.encode(state, m.title)
    c.uint.encode(state, flags)

    if (m.description) c.string.encode(state, m.description)
    if (m.category) c.string.encode(state, m.category)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      filePath: r0,
      title: r1,
      description: (flags & 1) !== 0 ? c.string.decode(state) : null,
      category: (flags & 2) !== 0 ? c.string.decode(state) : null,
      skipThumbnailGeneration: (version >= 3 && (flags & 4) !== 0)
    }
  }
}

// @peartube/upload-video-response.video
const encoding26_0 = encoding24_0

// @peartube/upload-video-response
const encoding26 = {
  preencode(state, m) {
    encoding26_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding26_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding26_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/subscription
const encoding27 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 4 so always one byte

    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.subscribedAt) c.uint.preencode(state, m.subscribedAt)
  },
  encode(state, m) {
    const flags =
      (m.channelName ? 1 : 0) |
      (m.avatar ? 2 : 0) |
      (m.subscribedAt ? 4 : 0)

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.subscribedAt) c.uint.encode(state, m.subscribedAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      channelName: (flags & 1) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 2) !== 0 ? c.string.decode(state) : null,
      subscribedAt: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/subscribe-channel-request
const encoding28 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      channelKey: r0
    }
  }
}

// @peartube/subscribe-channel-response
const encoding29 = encoding10

// @peartube/unsubscribe-channel-request
const encoding30 = encoding28

// @peartube/unsubscribe-channel-response
const encoding31 = encoding10

// @peartube/get-subscriptions-request
const encoding32 = encoding0

// @peartube/get-subscriptions-response.subscriptions
const encoding33_0 = c.array(c.frame(encoding27))

// @peartube/get-subscriptions-response
const encoding33 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.subscriptions) encoding33_0.preencode(state, m.subscriptions)
  },
  encode(state, m) {
    const flags = m.subscriptions ? 1 : 0

    c.uint.encode(state, flags)

    if (m.subscriptions) encoding33_0.encode(state, m.subscriptions)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      subscriptions: (flags & 1) !== 0 ? encoding33_0.decode(state) : null
    }
  }
}

// @peartube/join-channel-request
const encoding34 = encoding28

// @peartube/join-channel-response
const encoding35 = encoding10

// @peartube/feed-entry
const encoding36 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 8 so always one byte

    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
    if (m.peerCount) c.uint.preencode(state, m.peerCount)
    if (m.lastSeen) c.uint.preencode(state, m.lastSeen)
  },
  encode(state, m) {
    const flags =
      (m.channelName ? 1 : 0) |
      (m.videoCount ? 2 : 0) |
      (m.peerCount ? 4 : 0) |
      (m.lastSeen ? 8 : 0)

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
    if (m.peerCount) c.uint.encode(state, m.peerCount)
    if (m.lastSeen) c.uint.encode(state, m.lastSeen)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      channelName: (flags & 1) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      peerCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      lastSeen: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-public-feed-request
const encoding37 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.limit) c.uint.preencode(state, m.limit)
  },
  encode(state, m) {
    const flags = m.limit ? 1 : 0

    c.uint.encode(state, flags)

    if (m.limit) c.uint.encode(state, m.limit)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      limit: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-public-feed-response.entries
const encoding38_0 = c.array(c.frame(encoding36))

// @peartube/get-public-feed-response
const encoding38 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.entries) encoding38_0.preencode(state, m.entries)
  },
  encode(state, m) {
    const flags = m.entries ? 1 : 0

    c.uint.encode(state, flags)

    if (m.entries) encoding38_0.encode(state, m.entries)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      entries: (flags & 1) !== 0 ? encoding38_0.decode(state) : null
    }
  }
}

// @peartube/refresh-feed-request
const encoding39 = encoding0

// @peartube/refresh-feed-response
const encoding40 = encoding10

// @peartube/submit-to-feed-request
const encoding41 = encoding0

// @peartube/submit-to-feed-response
const encoding42 = encoding10

// @peartube/hide-channel-request
const encoding43 = encoding28

// @peartube/hide-channel-response
const encoding44 = encoding10

// @peartube/get-channel-meta-request
const encoding45 = encoding28

// @peartube/get-channel-meta-response
const encoding46 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.videoCount ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-swarm-status-request
const encoding47 = encoding0

// @peartube/get-swarm-status-response
const encoding48 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.peerCount) c.uint.preencode(state, m.peerCount)
  },
  encode(state, m) {
    const flags =
      (m.connected ? 1 : 0) |
      (m.peerCount ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.peerCount) c.uint.encode(state, m.peerCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      connected: (flags & 1) !== 0,
      peerCount: (flags & 2) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/prefetch-video-request
const encoding49 = encoding21

// @peartube/prefetch-video-response
const encoding50 = encoding10

// @peartube/video-stats
const encoding51 = {
  preencode(state, m) {
    const flags =
      (m.videoId ? 1 : 0) |
      (m.channelKey ? 2 : 0) |
      (m.status ? 4 : 0) |
      (m.progress ? 8 : 0) |
      (m.totalBlocks ? 16 : 0) |
      (m.downloadedBlocks ? 32 : 0) |
      (m.totalBytes ? 64 : 0) |
      (m.downloadedBytes ? 128 : 0) |
      (m.peerCount ? 256 : 0) |
      (m.speedMBps ? 512 : 0) |
      (m.uploadSpeedMBps ? 1024 : 0) |
      (m.elapsed ? 2048 : 0) |
      (m.isComplete ? 4096 : 0)

    c.uint.preencode(state, flags)

    if (m.videoId) c.string.preencode(state, m.videoId)
    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.status) c.string.preencode(state, m.status)
    if (m.progress) c.uint.preencode(state, m.progress)
    if (m.totalBlocks) c.uint.preencode(state, m.totalBlocks)
    if (m.downloadedBlocks) c.uint.preencode(state, m.downloadedBlocks)
    if (m.totalBytes) c.uint.preencode(state, m.totalBytes)
    if (m.downloadedBytes) c.uint.preencode(state, m.downloadedBytes)
    if (m.peerCount) c.uint.preencode(state, m.peerCount)
    if (m.speedMBps) c.string.preencode(state, m.speedMBps)
    if (m.uploadSpeedMBps) c.string.preencode(state, m.uploadSpeedMBps)
    if (m.elapsed) c.uint.preencode(state, m.elapsed)
  },
  encode(state, m) {
    const flags =
      (m.videoId ? 1 : 0) |
      (m.channelKey ? 2 : 0) |
      (m.status ? 4 : 0) |
      (m.progress ? 8 : 0) |
      (m.totalBlocks ? 16 : 0) |
      (m.downloadedBlocks ? 32 : 0) |
      (m.totalBytes ? 64 : 0) |
      (m.downloadedBytes ? 128 : 0) |
      (m.peerCount ? 256 : 0) |
      (m.speedMBps ? 512 : 0) |
      (m.uploadSpeedMBps ? 1024 : 0) |
      (m.elapsed ? 2048 : 0) |
      (m.isComplete ? 4096 : 0)

    c.uint.encode(state, flags)

    if (m.videoId) c.string.encode(state, m.videoId)
    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.status) c.string.encode(state, m.status)
    if (m.progress) c.uint.encode(state, m.progress)
    if (m.totalBlocks) c.uint.encode(state, m.totalBlocks)
    if (m.downloadedBlocks) c.uint.encode(state, m.downloadedBlocks)
    if (m.totalBytes) c.uint.encode(state, m.totalBytes)
    if (m.downloadedBytes) c.uint.encode(state, m.downloadedBytes)
    if (m.peerCount) c.uint.encode(state, m.peerCount)
    if (m.speedMBps) c.string.encode(state, m.speedMBps)
    if (m.uploadSpeedMBps) c.string.encode(state, m.uploadSpeedMBps)
    if (m.elapsed) c.uint.encode(state, m.elapsed)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      videoId: (flags & 1) !== 0 ? c.string.decode(state) : null,
      channelKey: (flags & 2) !== 0 ? c.string.decode(state) : null,
      status: (flags & 4) !== 0 ? c.string.decode(state) : null,
      progress: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      totalBlocks: (flags & 16) !== 0 ? c.uint.decode(state) : 0,
      downloadedBlocks: (flags & 32) !== 0 ? c.uint.decode(state) : 0,
      totalBytes: (flags & 64) !== 0 ? c.uint.decode(state) : 0,
      downloadedBytes: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      peerCount: (flags & 256) !== 0 ? c.uint.decode(state) : 0,
      speedMBps: (flags & 512) !== 0 ? c.string.decode(state) : null,
      uploadSpeedMBps: (flags & 1024) !== 0 ? c.string.decode(state) : null,
      elapsed: (flags & 2048) !== 0 ? c.uint.decode(state) : 0,
      isComplete: (flags & 4096) !== 0
    }
  }
}

// @peartube/get-video-stats-request
const encoding52 = encoding21

// @peartube/get-video-stats-response.stats
const encoding53_0 = c.frame(encoding51)

// @peartube/get-video-stats-response
const encoding53 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.stats) encoding53_0.preencode(state, m.stats)
  },
  encode(state, m) {
    const flags = m.stats ? 1 : 0

    c.uint.encode(state, flags)

    if (m.stats) encoding53_0.encode(state, m.stats)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      stats: (flags & 1) !== 0 ? encoding53_0.decode(state) : null
    }
  }
}

// @peartube/seeding-config
const encoding54 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.maxStorage) c.uint.preencode(state, m.maxStorage)
    if (m.maxBandwidth) c.uint.preencode(state, m.maxBandwidth)
  },
  encode(state, m) {
    const flags =
      (m.enabled ? 1 : 0) |
      (m.maxStorage ? 2 : 0) |
      (m.maxBandwidth ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.maxStorage) c.uint.encode(state, m.maxStorage)
    if (m.maxBandwidth) c.uint.encode(state, m.maxBandwidth)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      enabled: (flags & 1) !== 0,
      maxStorage: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      maxBandwidth: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/seeding-status
const encoding55 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.usedStorage) c.uint.preencode(state, m.usedStorage)
    if (m.maxStorage) c.uint.preencode(state, m.maxStorage)
    if (m.seedingCount) c.uint.preencode(state, m.seedingCount)
  },
  encode(state, m) {
    const flags =
      (m.enabled ? 1 : 0) |
      (m.usedStorage ? 2 : 0) |
      (m.maxStorage ? 4 : 0) |
      (m.seedingCount ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.usedStorage) c.uint.encode(state, m.usedStorage)
    if (m.maxStorage) c.uint.encode(state, m.maxStorage)
    if (m.seedingCount) c.uint.encode(state, m.seedingCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      enabled: (flags & 1) !== 0,
      usedStorage: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      maxStorage: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      seedingCount: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-seeding-status-request
const encoding56 = encoding0

// @peartube/get-seeding-status-response.status
const encoding57_0 = c.frame(encoding55)

// @peartube/get-seeding-status-response
const encoding57 = {
  preencode(state, m) {
    encoding57_0.preencode(state, m.status)
  },
  encode(state, m) {
    encoding57_0.encode(state, m.status)
  },
  decode(state) {
    const r0 = encoding57_0.decode(state)

    return {
      status: r0
    }
  }
}

// @peartube/set-seeding-config-request.config
const encoding58_0 = c.frame(encoding54)

// @peartube/set-seeding-config-request
const encoding58 = {
  preencode(state, m) {
    encoding58_0.preencode(state, m.config)
  },
  encode(state, m) {
    encoding58_0.encode(state, m.config)
  },
  decode(state) {
    const r0 = encoding58_0.decode(state)

    return {
      config: r0
    }
  }
}

// @peartube/set-seeding-config-response
const encoding59 = encoding10

// @peartube/pin-channel-request
const encoding60 = encoding28

// @peartube/pin-channel-response
const encoding61 = encoding10

// @peartube/unpin-channel-request
const encoding62 = encoding28

// @peartube/unpin-channel-response
const encoding63 = encoding10

// @peartube/get-pinned-channels-request
const encoding64 = encoding0

// @peartube/get-pinned-channels-response.channels
const encoding65_0 = c.array(c.string)

// @peartube/get-pinned-channels-response
const encoding65 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.channels) encoding65_0.preencode(state, m.channels)
  },
  encode(state, m) {
    const flags = m.channels ? 1 : 0

    c.uint.encode(state, flags)

    if (m.channels) encoding65_0.encode(state, m.channels)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channels: (flags & 1) !== 0 ? encoding65_0.decode(state) : null
    }
  }
}

// @peartube/get-video-thumbnail-request
const encoding66 = encoding21

// @peartube/get-video-thumbnail-response
const encoding67 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.url) c.string.preencode(state, m.url)
    if (m.dataUrl) c.string.preencode(state, m.dataUrl)
  },
  encode(state, m) {
    const flags =
      (m.url ? 1 : 0) |
      (m.dataUrl ? 2 : 0) |
      (m.exists ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.url) c.string.encode(state, m.url)
    if (m.dataUrl) c.string.encode(state, m.dataUrl)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      url: (flags & 1) !== 0 ? c.string.decode(state) : null,
      dataUrl: (flags & 2) !== 0 ? c.string.decode(state) : null,
      exists: (flags & 4) !== 0
    }
  }
}

// @peartube/get-video-metadata-request
const encoding68 = encoding21

// @peartube/get-video-metadata-response.video
const encoding69_0 = encoding24_0

// @peartube/get-video-metadata-response
const encoding69 = {
  preencode(state, m) {
    encoding69_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding69_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding69_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/set-video-thumbnail-request
const encoding70 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.imageData)
    state.end++ // max flag is 1 so always one byte

    if (m.mimeType) c.string.preencode(state, m.mimeType)
  },
  encode(state, m) {
    const flags = m.mimeType ? 1 : 0

    c.string.encode(state, m.videoId)
    c.string.encode(state, m.imageData)
    c.uint.encode(state, flags)

    if (m.mimeType) c.string.encode(state, m.mimeType)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      imageData: r1,
      mimeType: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/set-video-thumbnail-from-file-request
const encoding71 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.filePath)
  },
  encode(state, m) {
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.filePath)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      videoId: r0,
      filePath: r1
    }
  }
}

// @peartube/set-video-thumbnail-from-file-response
const encoding72 = encoding10

// @peartube/set-video-thumbnail-response
const encoding73 = encoding10

// @peartube/status
const encoding74 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.blobServerPort) c.uint.preencode(state, m.blobServerPort)
  },
  encode(state, m) {
    const flags =
      (m.ready ? 1 : 0) |
      (m.hasIdentity ? 2 : 0) |
      (m.blobServerPort ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.blobServerPort) c.uint.encode(state, m.blobServerPort)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      ready: (flags & 1) !== 0,
      hasIdentity: (flags & 2) !== 0,
      blobServerPort: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-status-request
const encoding75 = encoding0

// @peartube/get-status-response.status
const encoding76_0 = c.frame(encoding74)

// @peartube/get-status-response
const encoding76 = {
  preencode(state, m) {
    encoding76_0.preencode(state, m.status)
  },
  encode(state, m) {
    encoding76_0.encode(state, m.status)
  },
  decode(state) {
    const r0 = encoding76_0.decode(state)

    return {
      status: r0
    }
  }
}

// @peartube/pick-video-file-request
const encoding77 = encoding0

// @peartube/pick-video-file-response
const encoding78 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.filePath) c.string.preencode(state, m.filePath)
    if (m.name) c.string.preencode(state, m.name)
    if (m.size) c.uint.preencode(state, m.size)
  },
  encode(state, m) {
    const flags =
      (m.filePath ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.size ? 4 : 0) |
      (m.cancelled ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.filePath) c.string.encode(state, m.filePath)
    if (m.name) c.string.encode(state, m.name)
    if (m.size) c.uint.encode(state, m.size)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      filePath: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      size: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      cancelled: (flags & 8) !== 0
    }
  }
}

// @peartube/pick-image-file-request
const encoding79 = encoding0

// @peartube/pick-image-file-response
const encoding80 = {
  preencode(state, m) {
    state.end++ // max flag is 16 so always one byte

    if (m.filePath) c.string.preencode(state, m.filePath)
    if (m.name) c.string.preencode(state, m.name)
    if (m.size) c.uint.preencode(state, m.size)
    if (m.dataUrl) c.string.preencode(state, m.dataUrl)
  },
  encode(state, m) {
    const flags =
      (m.filePath ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.size ? 4 : 0) |
      (m.dataUrl ? 8 : 0) |
      (m.cancelled ? 16 : 0)

    c.uint.encode(state, flags)

    if (m.filePath) c.string.encode(state, m.filePath)
    if (m.name) c.string.encode(state, m.name)
    if (m.size) c.uint.encode(state, m.size)
    if (m.dataUrl) c.string.encode(state, m.dataUrl)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      filePath: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      size: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      dataUrl: (flags & 8) !== 0 ? c.string.decode(state) : null,
      cancelled: (flags & 16) !== 0
    }
  }
}

// @peartube/get-blob-server-port-request
const encoding81 = encoding0

// @peartube/get-blob-server-port-response
const encoding82 = {
  preencode(state, m) {
    c.uint.preencode(state, m.port)
  },
  encode(state, m) {
    c.uint.encode(state, m.port)
  },
  decode(state) {
    const r0 = c.uint.decode(state)

    return {
      port: r0
    }
  }
}

// @peartube/event-ready
const encoding83 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.blobServerPort) c.uint.preencode(state, m.blobServerPort)
  },
  encode(state, m) {
    const flags = m.blobServerPort ? 1 : 0

    c.uint.encode(state, flags)

    if (m.blobServerPort) c.uint.encode(state, m.blobServerPort)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      blobServerPort: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-error
const encoding84 = encoding1

// @peartube/event-upload-progress
const encoding85 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.uint.preencode(state, m.progress)
    state.end++ // max flag is 2 so always one byte

    if (m.bytesUploaded) c.uint.preencode(state, m.bytesUploaded)
    if (m.totalBytes) c.uint.preencode(state, m.totalBytes)
  },
  encode(state, m) {
    const flags =
      (m.bytesUploaded ? 1 : 0) |
      (m.totalBytes ? 2 : 0)

    c.string.encode(state, m.videoId)
    c.uint.encode(state, m.progress)
    c.uint.encode(state, flags)

    if (m.bytesUploaded) c.uint.encode(state, m.bytesUploaded)
    if (m.totalBytes) c.uint.encode(state, m.totalBytes)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      progress: r1,
      bytesUploaded: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      totalBytes: (flags & 2) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-feed-update
const encoding86 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.action)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.action)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      channelKey: r0,
      action: r1
    }
  }
}

// @peartube/event-log
const encoding87 = {
  preencode(state, m) {
    c.string.preencode(state, m.level)
    c.string.preencode(state, m.message)
    state.end++ // max flag is 1 so always one byte

    if (m.timestamp) c.uint.preencode(state, m.timestamp)
  },
  encode(state, m) {
    const flags = m.timestamp ? 1 : 0

    c.string.encode(state, m.level)
    c.string.encode(state, m.message)
    c.uint.encode(state, flags)

    if (m.timestamp) c.uint.encode(state, m.timestamp)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      level: r0,
      message: r1,
      timestamp: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-video-stats.stats
const encoding88_0 = encoding53_0

// @peartube/event-video-stats
const encoding88 = {
  preencode(state, m) {
    encoding88_0.preencode(state, m.stats)
  },
  encode(state, m) {
    encoding88_0.encode(state, m.stats)
  },
  decode(state) {
    const r0 = encoding88_0.decode(state)

    return {
      stats: r0
    }
  }
}

// @peartube/download-video-request
const encoding89 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.destPath)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.destPath)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      destPath: r2
    }
  }
}

// @peartube/download-video-response
const encoding90 = {
  preencode(state, m) {
    state.end++ // max flag is 16 so always one byte

    if (version >= 2 && m.filePath) c.string.preencode(state, m.filePath)
    if (version >= 2 && m.size) c.uint.preencode(state, m.size)
    if (version >= 2 && m.error) c.string.preencode(state, m.error)
    if (version >= 4 && m.data) c.string.preencode(state, m.data)
  },
  encode(state, m) {
    const flags =
      ((version >= 2 && m.success) ? 1 : 0) |
      ((version >= 2 && m.filePath) ? 2 : 0) |
      ((version >= 2 && m.size) ? 4 : 0) |
      ((version >= 2 && m.error) ? 8 : 0) |
      ((version >= 4 && m.data) ? 16 : 0)

    c.uint.encode(state, flags)

    if (version >= 2 && m.filePath) c.string.encode(state, m.filePath)
    if (version >= 2 && m.size) c.uint.encode(state, m.size)
    if (version >= 2 && m.error) c.string.encode(state, m.error)
    if (version >= 4 && m.data) c.string.encode(state, m.data)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 2 && (flags & 1) !== 0),
      filePath: (version >= 2 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      size: (version >= 2 && (flags & 4) !== 0) ? c.uint.decode(state) : 0,
      error: (version >= 2 && (flags & 8) !== 0) ? c.string.decode(state) : null,
      data: (version >= 4 && (flags & 16) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/delete-video-request
const encoding91 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
  },
  encode(state, m) {
    c.string.encode(state, m.videoId)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      videoId: r0
    }
  }
}

// @peartube/delete-video-response
const encoding92 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (version >= 5 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 5 && m.success) ? 1 : 0) |
      ((version >= 5 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)

    if (version >= 5 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 5 && (flags & 1) !== 0),
      error: (version >= 5 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-storage-stats-request
const encoding93 = encoding0

// @peartube/get-storage-stats-response
const encoding94 = {
  preencode(state, m) {
    c.uint.preencode(state, m.usedBytes)
    c.uint.preencode(state, m.maxBytes)
    c.string.preencode(state, m.usedGB)
    c.uint.preencode(state, m.maxGB)
    c.uint.preencode(state, m.seedCount)
    c.uint.preencode(state, m.pinnedCount)
  },
  encode(state, m) {
    c.uint.encode(state, m.usedBytes)
    c.uint.encode(state, m.maxBytes)
    c.string.encode(state, m.usedGB)
    c.uint.encode(state, m.maxGB)
    c.uint.encode(state, m.seedCount)
    c.uint.encode(state, m.pinnedCount)
  },
  decode(state) {
    const r0 = c.uint.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.string.decode(state)
    const r3 = c.uint.decode(state)
    const r4 = c.uint.decode(state)
    const r5 = c.uint.decode(state)

    return {
      usedBytes: r0,
      maxBytes: r1,
      usedGB: r2,
      maxGB: r3,
      seedCount: r4,
      pinnedCount: r5
    }
  }
}

// @peartube/set-storage-limit-request
const encoding95 = {
  preencode(state, m) {
    c.uint.preencode(state, m.maxGB)
  },
  encode(state, m) {
    c.uint.encode(state, m.maxGB)
  },
  decode(state) {
    const r0 = c.uint.decode(state)

    return {
      maxGB: r0
    }
  }
}

// @peartube/set-storage-limit-response
const encoding96 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = (version >= 6 && m.success) ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 6 && (flags & 1) !== 0)
    }
  }
}

// @peartube/clear-cache-request
const encoding97 = encoding0

// @peartube/clear-cache-response
const encoding98 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (version >= 6 && m.clearedBytes) c.uint.preencode(state, m.clearedBytes)
  },
  encode(state, m) {
    const flags =
      ((version >= 6 && m.success) ? 1 : 0) |
      ((version >= 6 && m.clearedBytes) ? 2 : 0)

    c.uint.encode(state, flags)

    if (version >= 6 && m.clearedBytes) c.uint.encode(state, m.clearedBytes)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 6 && (flags & 1) !== 0),
      clearedBytes: (version >= 6 && (flags & 2) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/unpublish-from-feed-request
const encoding99 = encoding0

// @peartube/unpublish-from-feed-response
const encoding100 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = (version >= 7 && m.success) ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 7 && (flags & 1) !== 0)
    }
  }
}

// @peartube/is-channel-published-request
const encoding101 = encoding0

// @peartube/is-channel-published-response
const encoding102 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = (version >= 7 && m.published) ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      published: (version >= 7 && (flags & 1) !== 0)
    }
  }
}

function setVersion(v) {
  version = v
}

function encode(name, value, v = VERSION) {
  version = v
  return c.encode(getEncoding(name), value)
}

function decode(name, buffer, v = VERSION) {
  version = v
  return c.decode(getEncoding(name), buffer)
}

function getEnum(name) {
  switch (name) {
    default:
      throw new Error('Enum not found ' + name)
  }
}

function getEncoding(name) {
  switch (name) {
    case '@peartube/empty':
      return encoding0
    case '@peartube/error':
      return encoding1
    case '@peartube/identity':
      return encoding2
    case '@peartube/create-identity-request':
      return encoding3
    case '@peartube/create-identity-response':
      return encoding4
    case '@peartube/get-identity-request':
      return encoding5
    case '@peartube/get-identity-response':
      return encoding6
    case '@peartube/get-identities-request':
      return encoding7
    case '@peartube/get-identities-response':
      return encoding8
    case '@peartube/set-active-identity-request':
      return encoding9
    case '@peartube/set-active-identity-response':
      return encoding10
    case '@peartube/recover-identity-request':
      return encoding11
    case '@peartube/recover-identity-response':
      return encoding12
    case '@peartube/channel':
      return encoding13
    case '@peartube/get-channel-request':
      return encoding14
    case '@peartube/get-channel-response':
      return encoding15
    case '@peartube/update-channel-request':
      return encoding16
    case '@peartube/update-channel-response':
      return encoding17
    case '@peartube/video':
      return encoding18
    case '@peartube/list-videos-request':
      return encoding19
    case '@peartube/list-videos-response':
      return encoding20
    case '@peartube/get-video-url-request':
      return encoding21
    case '@peartube/get-video-url-response':
      return encoding22
    case '@peartube/get-video-data-request':
      return encoding23
    case '@peartube/get-video-data-response':
      return encoding24
    case '@peartube/upload-video-request':
      return encoding25
    case '@peartube/upload-video-response':
      return encoding26
    case '@peartube/subscription':
      return encoding27
    case '@peartube/subscribe-channel-request':
      return encoding28
    case '@peartube/subscribe-channel-response':
      return encoding29
    case '@peartube/unsubscribe-channel-request':
      return encoding30
    case '@peartube/unsubscribe-channel-response':
      return encoding31
    case '@peartube/get-subscriptions-request':
      return encoding32
    case '@peartube/get-subscriptions-response':
      return encoding33
    case '@peartube/join-channel-request':
      return encoding34
    case '@peartube/join-channel-response':
      return encoding35
    case '@peartube/feed-entry':
      return encoding36
    case '@peartube/get-public-feed-request':
      return encoding37
    case '@peartube/get-public-feed-response':
      return encoding38
    case '@peartube/refresh-feed-request':
      return encoding39
    case '@peartube/refresh-feed-response':
      return encoding40
    case '@peartube/submit-to-feed-request':
      return encoding41
    case '@peartube/submit-to-feed-response':
      return encoding42
    case '@peartube/hide-channel-request':
      return encoding43
    case '@peartube/hide-channel-response':
      return encoding44
    case '@peartube/get-channel-meta-request':
      return encoding45
    case '@peartube/get-channel-meta-response':
      return encoding46
    case '@peartube/get-swarm-status-request':
      return encoding47
    case '@peartube/get-swarm-status-response':
      return encoding48
    case '@peartube/prefetch-video-request':
      return encoding49
    case '@peartube/prefetch-video-response':
      return encoding50
    case '@peartube/video-stats':
      return encoding51
    case '@peartube/get-video-stats-request':
      return encoding52
    case '@peartube/get-video-stats-response':
      return encoding53
    case '@peartube/seeding-config':
      return encoding54
    case '@peartube/seeding-status':
      return encoding55
    case '@peartube/get-seeding-status-request':
      return encoding56
    case '@peartube/get-seeding-status-response':
      return encoding57
    case '@peartube/set-seeding-config-request':
      return encoding58
    case '@peartube/set-seeding-config-response':
      return encoding59
    case '@peartube/pin-channel-request':
      return encoding60
    case '@peartube/pin-channel-response':
      return encoding61
    case '@peartube/unpin-channel-request':
      return encoding62
    case '@peartube/unpin-channel-response':
      return encoding63
    case '@peartube/get-pinned-channels-request':
      return encoding64
    case '@peartube/get-pinned-channels-response':
      return encoding65
    case '@peartube/get-video-thumbnail-request':
      return encoding66
    case '@peartube/get-video-thumbnail-response':
      return encoding67
    case '@peartube/get-video-metadata-request':
      return encoding68
    case '@peartube/get-video-metadata-response':
      return encoding69
    case '@peartube/set-video-thumbnail-request':
      return encoding70
    case '@peartube/set-video-thumbnail-from-file-request':
      return encoding71
    case '@peartube/set-video-thumbnail-from-file-response':
      return encoding72
    case '@peartube/set-video-thumbnail-response':
      return encoding73
    case '@peartube/status':
      return encoding74
    case '@peartube/get-status-request':
      return encoding75
    case '@peartube/get-status-response':
      return encoding76
    case '@peartube/pick-video-file-request':
      return encoding77
    case '@peartube/pick-video-file-response':
      return encoding78
    case '@peartube/pick-image-file-request':
      return encoding79
    case '@peartube/pick-image-file-response':
      return encoding80
    case '@peartube/get-blob-server-port-request':
      return encoding81
    case '@peartube/get-blob-server-port-response':
      return encoding82
    case '@peartube/event-ready':
      return encoding83
    case '@peartube/event-error':
      return encoding84
    case '@peartube/event-upload-progress':
      return encoding85
    case '@peartube/event-feed-update':
      return encoding86
    case '@peartube/event-log':
      return encoding87
    case '@peartube/event-video-stats':
      return encoding88
    case '@peartube/download-video-request':
      return encoding89
    case '@peartube/download-video-response':
      return encoding90
    case '@peartube/delete-video-request':
      return encoding91
    case '@peartube/delete-video-response':
      return encoding92
    case '@peartube/get-storage-stats-request':
      return encoding93
    case '@peartube/get-storage-stats-response':
      return encoding94
    case '@peartube/set-storage-limit-request':
      return encoding95
    case '@peartube/set-storage-limit-response':
      return encoding96
    case '@peartube/clear-cache-request':
      return encoding97
    case '@peartube/clear-cache-response':
      return encoding98
    case '@peartube/unpublish-from-feed-request':
      return encoding99
    case '@peartube/unpublish-from-feed-response':
      return encoding100
    case '@peartube/is-channel-published-request':
      return encoding101
    case '@peartube/is-channel-published-response':
      return encoding102
    default:
      throw new Error('Encoder not found ' + name)
  }
}

function getStruct(name, v = VERSION) {
  const enc = getEncoding(name)
  return {
    preencode(state, m) {
      version = v
      enc.preencode(state, m)
    },
    encode(state, m) {
      version = v
      enc.encode(state, m)
    },
    decode(state) {
      version = v
      return enc.decode(state)
    }
  }
}

const resolveStruct = getStruct // compat

module.exports = {
  resolveStruct,
  getStruct,
  getEnum,
  getEncoding,
  encode,
  decode,
  setVersion,
  version
}
