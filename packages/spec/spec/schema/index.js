// This file is autogenerated by the hyperschema compiler
// Schema Version: 11
/* eslint-disable camelcase */
/* eslint-disable quotes */
/* eslint-disable space-before-function-paren */

const { c } = require('hyperschema/runtime')

const VERSION = 11

// eslint-disable-next-line no-unused-vars
let version = VERSION

// @peartube/empty
const encoding0 = {
  preencode(state, m) {

  },
  encode(state, m) {

  },
  decode(state) {
    return {
    }
  }
}

// @peartube/error
const encoding1 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.code) c.uint.preencode(state, m.code)
    c.string.preencode(state, m.message)
  },
  encode(state, m) {
    const flags = m.code ? 1 : 0

    c.uint.encode(state, flags)

    if (m.code) c.uint.encode(state, m.code)
    c.string.encode(state, m.message)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      code: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      message: c.string.decode(state)
    }
  }
}

// @peartube/identity
const encoding2 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
    state.end++ // max flag is 32 so always one byte

    if (m.driveKey) c.string.preencode(state, m.driveKey)
    if (m.name) c.string.preencode(state, m.name)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.seedPhrase) c.string.preencode(state, m.seedPhrase)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
  },
  encode(state, m) {
    const flags =
      (m.driveKey ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.avatar ? 4 : 0) |
      (m.seedPhrase ? 8 : 0) |
      (m.createdAt ? 16 : 0) |
      (m.isActive ? 32 : 0)

    c.string.encode(state, m.publicKey)
    c.uint.encode(state, flags)

    if (m.driveKey) c.string.encode(state, m.driveKey)
    if (m.name) c.string.encode(state, m.name)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.seedPhrase) c.string.encode(state, m.seedPhrase)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      publicKey: r0,
      driveKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null,
      seedPhrase: (flags & 8) !== 0 ? c.string.decode(state) : null,
      createdAt: (flags & 16) !== 0 ? c.uint.decode(state) : 0,
      isActive: (flags & 32) !== 0
    }
  }
}

// @peartube/create-identity-request
const encoding3 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.avatar) c.string.preencode(state, m.avatar)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.avatar ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.avatar) c.string.encode(state, m.avatar)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/create-identity-response.identity
const encoding4_0 = c.frame(encoding2)

// @peartube/create-identity-response
const encoding4 = {
  preencode(state, m) {
    encoding4_0.preencode(state, m.identity)
  },
  encode(state, m) {
    encoding4_0.encode(state, m.identity)
  },
  decode(state) {
    const r0 = encoding4_0.decode(state)

    return {
      identity: r0
    }
  }
}

// @peartube/get-identity-request
const encoding5 = encoding0

// @peartube/get-identity-response.identity
const encoding6_0 = encoding4_0

// @peartube/get-identity-response
const encoding6 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.identity) encoding6_0.preencode(state, m.identity)
  },
  encode(state, m) {
    const flags = m.identity ? 1 : 0

    c.uint.encode(state, flags)

    if (m.identity) encoding6_0.encode(state, m.identity)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      identity: (flags & 1) !== 0 ? encoding6_0.decode(state) : null
    }
  }
}

// @peartube/get-identities-request
const encoding7 = encoding0

// @peartube/get-identities-response.identities
const encoding8_0 = c.array(c.frame(encoding2))

// @peartube/get-identities-response
const encoding8 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.identities) encoding8_0.preencode(state, m.identities)
  },
  encode(state, m) {
    const flags = m.identities ? 1 : 0

    c.uint.encode(state, flags)

    if (m.identities) encoding8_0.encode(state, m.identities)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      identities: (flags & 1) !== 0 ? encoding8_0.decode(state) : null
    }
  }
}

// @peartube/set-active-identity-request
const encoding9 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
  },
  encode(state, m) {
    c.string.encode(state, m.publicKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      publicKey: r0
    }
  }
}

// @peartube/set-active-identity-response
const encoding10 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = m.success ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0
    }
  }
}

// @peartube/recover-identity-request
const encoding11 = {
  preencode(state, m) {
    c.string.preencode(state, m.seedPhrase)
  },
  encode(state, m) {
    c.string.encode(state, m.seedPhrase)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      seedPhrase: r0
    }
  }
}

// @peartube/recover-identity-response.identity
const encoding12_0 = encoding4_0

// @peartube/recover-identity-response
const encoding12 = {
  preencode(state, m) {
    encoding12_0.preencode(state, m.identity)
  },
  encode(state, m) {
    encoding12_0.encode(state, m.identity)
  },
  decode(state) {
    const r0 = encoding12_0.decode(state)

    return {
      identity: r0
    }
  }
}

// @peartube/channel
const encoding13 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
    state.end++ // max flag is 16 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
    if (m.subscriberCount) c.uint.preencode(state, m.subscriberCount)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.avatar ? 4 : 0) |
      (m.videoCount ? 8 : 0) |
      (m.subscriberCount ? 16 : 0)

    c.string.encode(state, m.publicKey)
    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
    if (m.subscriberCount) c.uint.encode(state, m.subscriberCount)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      publicKey: r0,
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      subscriberCount: (flags & 16) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-channel-request
const encoding14 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.publicKey) c.string.preencode(state, m.publicKey)
  },
  encode(state, m) {
    const flags = m.publicKey ? 1 : 0

    c.uint.encode(state, flags)

    if (m.publicKey) c.string.encode(state, m.publicKey)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      publicKey: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-channel-response.channel
const encoding15_0 = c.frame(encoding13)

// @peartube/get-channel-response
const encoding15 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.channel) encoding15_0.preencode(state, m.channel)
  },
  encode(state, m) {
    const flags = m.channel ? 1 : 0

    c.uint.encode(state, flags)

    if (m.channel) encoding15_0.encode(state, m.channel)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channel: (flags & 1) !== 0 ? encoding15_0.decode(state) : null
    }
  }
}

// @peartube/update-channel-request
const encoding16 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.avatar) c.string.preencode(state, m.avatar)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.avatar ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.avatar) c.string.encode(state, m.avatar)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/update-channel-response.channel
const encoding17_0 = encoding15_0

// @peartube/update-channel-response
const encoding17 = {
  preencode(state, m) {
    encoding17_0.preencode(state, m.channel)
  },
  encode(state, m) {
    encoding17_0.encode(state, m.channel)
  },
  decode(state) {
    const r0 = encoding17_0.decode(state)

    return {
      channel: r0
    }
  }
}

// @peartube/video
const encoding18 = {
  preencode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.path ? 2 : 0) |
      (m.duration ? 4 : 0) |
      (m.thumbnail ? 8 : 0) |
      (m.channelKey ? 16 : 0) |
      (m.channelName ? 32 : 0) |
      (m.createdAt ? 64 : 0) |
      (m.views ? 128 : 0) |
      (m.category ? 256 : 0)

    c.string.preencode(state, m.id)
    c.string.preencode(state, m.title)
    c.uint.preencode(state, flags)

    if (m.description) c.string.preencode(state, m.description)
    if (m.path) c.string.preencode(state, m.path)
    if (m.duration) c.uint.preencode(state, m.duration)
    if (m.thumbnail) c.string.preencode(state, m.thumbnail)
    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
    if (m.views) c.uint.preencode(state, m.views)
    if (m.category) c.string.preencode(state, m.category)
  },
  encode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.path ? 2 : 0) |
      (m.duration ? 4 : 0) |
      (m.thumbnail ? 8 : 0) |
      (m.channelKey ? 16 : 0) |
      (m.channelName ? 32 : 0) |
      (m.createdAt ? 64 : 0) |
      (m.views ? 128 : 0) |
      (m.category ? 256 : 0)

    c.string.encode(state, m.id)
    c.string.encode(state, m.title)
    c.uint.encode(state, flags)

    if (m.description) c.string.encode(state, m.description)
    if (m.path) c.string.encode(state, m.path)
    if (m.duration) c.uint.encode(state, m.duration)
    if (m.thumbnail) c.string.encode(state, m.thumbnail)
    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
    if (m.views) c.uint.encode(state, m.views)
    if (m.category) c.string.encode(state, m.category)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      id: r0,
      title: r1,
      description: (flags & 1) !== 0 ? c.string.decode(state) : null,
      path: (flags & 2) !== 0 ? c.string.decode(state) : null,
      duration: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      thumbnail: (flags & 8) !== 0 ? c.string.decode(state) : null,
      channelKey: (flags & 16) !== 0 ? c.string.decode(state) : null,
      channelName: (flags & 32) !== 0 ? c.string.decode(state) : null,
      createdAt: (flags & 64) !== 0 ? c.uint.decode(state) : 0,
      views: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      category: (flags & 256) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/list-videos-request
const encoding19 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.limit) c.uint.preencode(state, m.limit)
    if (m.offset) c.uint.preencode(state, m.offset)
  },
  encode(state, m) {
    const flags =
      (m.channelKey ? 1 : 0) |
      (m.limit ? 2 : 0) |
      (m.offset ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.limit) c.uint.encode(state, m.limit)
    if (m.offset) c.uint.encode(state, m.offset)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channelKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      limit: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      offset: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/list-videos-response.videos
const encoding20_0 = c.array(c.frame(encoding18))

// @peartube/list-videos-response
const encoding20 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.videos) encoding20_0.preencode(state, m.videos)
  },
  encode(state, m) {
    const flags = m.videos ? 1 : 0

    c.uint.encode(state, flags)

    if (m.videos) encoding20_0.encode(state, m.videos)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      videos: (flags & 1) !== 0 ? encoding20_0.decode(state) : null
    }
  }
}

// @peartube/get-video-url-request
const encoding21 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      channelKey: r0,
      videoId: r1
    }
  }
}

// @peartube/get-video-url-response
const encoding22 = {
  preencode(state, m) {
    c.string.preencode(state, m.url)
  },
  encode(state, m) {
    c.string.encode(state, m.url)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      url: r0
    }
  }
}

// @peartube/get-video-data-request
const encoding23 = encoding21

// @peartube/get-video-data-response.video
const encoding24_0 = c.frame(encoding18)

// @peartube/get-video-data-response
const encoding24 = {
  preencode(state, m) {
    encoding24_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding24_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding24_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/upload-video-request
const encoding25 = {
  preencode(state, m) {
    c.string.preencode(state, m.filePath)
    c.string.preencode(state, m.title)
    state.end++ // max flag is 4 so always one byte

    if (m.description) c.string.preencode(state, m.description)
    if (m.category) c.string.preencode(state, m.category)
  },
  encode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.category ? 2 : 0) |
      ((version >= 3 && m.skipThumbnailGeneration) ? 4 : 0)

    c.string.encode(state, m.filePath)
    c.string.encode(state, m.title)
    c.uint.encode(state, flags)

    if (m.description) c.string.encode(state, m.description)
    if (m.category) c.string.encode(state, m.category)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      filePath: r0,
      title: r1,
      description: (flags & 1) !== 0 ? c.string.decode(state) : null,
      category: (flags & 2) !== 0 ? c.string.decode(state) : null,
      skipThumbnailGeneration: (version >= 3 && (flags & 4) !== 0)
    }
  }
}

// @peartube/upload-video-response.video
const encoding26_0 = encoding24_0

// @peartube/upload-video-response
const encoding26 = {
  preencode(state, m) {
    encoding26_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding26_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding26_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/subscription
const encoding27 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 4 so always one byte

    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.subscribedAt) c.uint.preencode(state, m.subscribedAt)
  },
  encode(state, m) {
    const flags =
      (m.channelName ? 1 : 0) |
      (m.avatar ? 2 : 0) |
      (m.subscribedAt ? 4 : 0)

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.subscribedAt) c.uint.encode(state, m.subscribedAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      channelName: (flags & 1) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 2) !== 0 ? c.string.decode(state) : null,
      subscribedAt: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/subscribe-channel-request
const encoding28 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      channelKey: r0
    }
  }
}

// @peartube/subscribe-channel-response
const encoding29 = encoding10

// @peartube/unsubscribe-channel-request
const encoding30 = encoding28

// @peartube/unsubscribe-channel-response
const encoding31 = encoding10

// @peartube/get-subscriptions-request
const encoding32 = encoding0

// @peartube/get-subscriptions-response.subscriptions
const encoding33_0 = c.array(c.frame(encoding27))

// @peartube/get-subscriptions-response
const encoding33 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.subscriptions) encoding33_0.preencode(state, m.subscriptions)
  },
  encode(state, m) {
    const flags = m.subscriptions ? 1 : 0

    c.uint.encode(state, flags)

    if (m.subscriptions) encoding33_0.encode(state, m.subscriptions)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      subscriptions: (flags & 1) !== 0 ? encoding33_0.decode(state) : null
    }
  }
}

// @peartube/join-channel-request
const encoding34 = encoding28

// @peartube/join-channel-response
const encoding35 = encoding10

// @peartube/feed-entry
const encoding36 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 8 so always one byte

    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
    if (m.peerCount) c.uint.preencode(state, m.peerCount)
    if (m.lastSeen) c.uint.preencode(state, m.lastSeen)
  },
  encode(state, m) {
    const flags =
      (m.channelName ? 1 : 0) |
      (m.videoCount ? 2 : 0) |
      (m.peerCount ? 4 : 0) |
      (m.lastSeen ? 8 : 0)

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
    if (m.peerCount) c.uint.encode(state, m.peerCount)
    if (m.lastSeen) c.uint.encode(state, m.lastSeen)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      channelName: (flags & 1) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      peerCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      lastSeen: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-public-feed-request
const encoding37 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.limit) c.uint.preencode(state, m.limit)
  },
  encode(state, m) {
    const flags = m.limit ? 1 : 0

    c.uint.encode(state, flags)

    if (m.limit) c.uint.encode(state, m.limit)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      limit: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-public-feed-response.entries
const encoding38_0 = c.array(c.frame(encoding36))

// @peartube/get-public-feed-response
const encoding38 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.entries) encoding38_0.preencode(state, m.entries)
  },
  encode(state, m) {
    const flags = m.entries ? 1 : 0

    c.uint.encode(state, flags)

    if (m.entries) encoding38_0.encode(state, m.entries)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      entries: (flags & 1) !== 0 ? encoding38_0.decode(state) : null
    }
  }
}

// @peartube/refresh-feed-request
const encoding39 = encoding0

// @peartube/refresh-feed-response
const encoding40 = encoding10

// @peartube/submit-to-feed-request
const encoding41 = encoding0

// @peartube/submit-to-feed-response
const encoding42 = encoding10

// @peartube/hide-channel-request
const encoding43 = encoding28

// @peartube/hide-channel-response
const encoding44 = encoding10

// @peartube/get-channel-meta-request
const encoding45 = encoding28

// @peartube/get-channel-meta-response
const encoding46 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.videoCount ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-swarm-status-request
const encoding47 = encoding0

// @peartube/get-swarm-status-response
const encoding48 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.peerCount) c.uint.preencode(state, m.peerCount)
  },
  encode(state, m) {
    const flags =
      (m.connected ? 1 : 0) |
      (m.peerCount ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.peerCount) c.uint.encode(state, m.peerCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      connected: (flags & 1) !== 0,
      peerCount: (flags & 2) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/prefetch-video-request
const encoding49 = encoding21

// @peartube/prefetch-video-response
const encoding50 = encoding10

// @peartube/video-stats
const encoding51 = {
  preencode(state, m) {
    const flags =
      (m.videoId ? 1 : 0) |
      (m.channelKey ? 2 : 0) |
      (m.status ? 4 : 0) |
      (m.progress ? 8 : 0) |
      (m.totalBlocks ? 16 : 0) |
      (m.downloadedBlocks ? 32 : 0) |
      (m.totalBytes ? 64 : 0) |
      (m.downloadedBytes ? 128 : 0) |
      (m.peerCount ? 256 : 0) |
      (m.speedMBps ? 512 : 0) |
      (m.uploadSpeedMBps ? 1024 : 0) |
      (m.elapsed ? 2048 : 0) |
      (m.isComplete ? 4096 : 0)

    c.uint.preencode(state, flags)

    if (m.videoId) c.string.preencode(state, m.videoId)
    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.status) c.string.preencode(state, m.status)
    if (m.progress) c.uint.preencode(state, m.progress)
    if (m.totalBlocks) c.uint.preencode(state, m.totalBlocks)
    if (m.downloadedBlocks) c.uint.preencode(state, m.downloadedBlocks)
    if (m.totalBytes) c.uint.preencode(state, m.totalBytes)
    if (m.downloadedBytes) c.uint.preencode(state, m.downloadedBytes)
    if (m.peerCount) c.uint.preencode(state, m.peerCount)
    if (m.speedMBps) c.string.preencode(state, m.speedMBps)
    if (m.uploadSpeedMBps) c.string.preencode(state, m.uploadSpeedMBps)
    if (m.elapsed) c.uint.preencode(state, m.elapsed)
  },
  encode(state, m) {
    const flags =
      (m.videoId ? 1 : 0) |
      (m.channelKey ? 2 : 0) |
      (m.status ? 4 : 0) |
      (m.progress ? 8 : 0) |
      (m.totalBlocks ? 16 : 0) |
      (m.downloadedBlocks ? 32 : 0) |
      (m.totalBytes ? 64 : 0) |
      (m.downloadedBytes ? 128 : 0) |
      (m.peerCount ? 256 : 0) |
      (m.speedMBps ? 512 : 0) |
      (m.uploadSpeedMBps ? 1024 : 0) |
      (m.elapsed ? 2048 : 0) |
      (m.isComplete ? 4096 : 0)

    c.uint.encode(state, flags)

    if (m.videoId) c.string.encode(state, m.videoId)
    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.status) c.string.encode(state, m.status)
    if (m.progress) c.uint.encode(state, m.progress)
    if (m.totalBlocks) c.uint.encode(state, m.totalBlocks)
    if (m.downloadedBlocks) c.uint.encode(state, m.downloadedBlocks)
    if (m.totalBytes) c.uint.encode(state, m.totalBytes)
    if (m.downloadedBytes) c.uint.encode(state, m.downloadedBytes)
    if (m.peerCount) c.uint.encode(state, m.peerCount)
    if (m.speedMBps) c.string.encode(state, m.speedMBps)
    if (m.uploadSpeedMBps) c.string.encode(state, m.uploadSpeedMBps)
    if (m.elapsed) c.uint.encode(state, m.elapsed)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      videoId: (flags & 1) !== 0 ? c.string.decode(state) : null,
      channelKey: (flags & 2) !== 0 ? c.string.decode(state) : null,
      status: (flags & 4) !== 0 ? c.string.decode(state) : null,
      progress: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      totalBlocks: (flags & 16) !== 0 ? c.uint.decode(state) : 0,
      downloadedBlocks: (flags & 32) !== 0 ? c.uint.decode(state) : 0,
      totalBytes: (flags & 64) !== 0 ? c.uint.decode(state) : 0,
      downloadedBytes: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      peerCount: (flags & 256) !== 0 ? c.uint.decode(state) : 0,
      speedMBps: (flags & 512) !== 0 ? c.string.decode(state) : null,
      uploadSpeedMBps: (flags & 1024) !== 0 ? c.string.decode(state) : null,
      elapsed: (flags & 2048) !== 0 ? c.uint.decode(state) : 0,
      isComplete: (flags & 4096) !== 0
    }
  }
}

// @peartube/get-video-stats-request
const encoding52 = encoding21

// @peartube/get-video-stats-response.stats
const encoding53_0 = c.frame(encoding51)

// @peartube/get-video-stats-response
const encoding53 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.stats) encoding53_0.preencode(state, m.stats)
  },
  encode(state, m) {
    const flags = m.stats ? 1 : 0

    c.uint.encode(state, flags)

    if (m.stats) encoding53_0.encode(state, m.stats)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      stats: (flags & 1) !== 0 ? encoding53_0.decode(state) : null
    }
  }
}

// @peartube/seeding-config
const encoding54 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.maxStorage) c.uint.preencode(state, m.maxStorage)
    if (m.maxBandwidth) c.uint.preencode(state, m.maxBandwidth)
  },
  encode(state, m) {
    const flags =
      (m.enabled ? 1 : 0) |
      (m.maxStorage ? 2 : 0) |
      (m.maxBandwidth ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.maxStorage) c.uint.encode(state, m.maxStorage)
    if (m.maxBandwidth) c.uint.encode(state, m.maxBandwidth)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      enabled: (flags & 1) !== 0,
      maxStorage: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      maxBandwidth: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/seeding-status
const encoding55 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.usedStorage) c.uint.preencode(state, m.usedStorage)
    if (m.maxStorage) c.uint.preencode(state, m.maxStorage)
    if (m.seedingCount) c.uint.preencode(state, m.seedingCount)
  },
  encode(state, m) {
    const flags =
      (m.enabled ? 1 : 0) |
      (m.usedStorage ? 2 : 0) |
      (m.maxStorage ? 4 : 0) |
      (m.seedingCount ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.usedStorage) c.uint.encode(state, m.usedStorage)
    if (m.maxStorage) c.uint.encode(state, m.maxStorage)
    if (m.seedingCount) c.uint.encode(state, m.seedingCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      enabled: (flags & 1) !== 0,
      usedStorage: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      maxStorage: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      seedingCount: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-seeding-status-request
const encoding56 = encoding0

// @peartube/get-seeding-status-response.status
const encoding57_0 = c.frame(encoding55)

// @peartube/get-seeding-status-response
const encoding57 = {
  preencode(state, m) {
    encoding57_0.preencode(state, m.status)
  },
  encode(state, m) {
    encoding57_0.encode(state, m.status)
  },
  decode(state) {
    const r0 = encoding57_0.decode(state)

    return {
      status: r0
    }
  }
}

// @peartube/set-seeding-config-request.config
const encoding58_0 = c.frame(encoding54)

// @peartube/set-seeding-config-request
const encoding58 = {
  preencode(state, m) {
    encoding58_0.preencode(state, m.config)
  },
  encode(state, m) {
    encoding58_0.encode(state, m.config)
  },
  decode(state) {
    const r0 = encoding58_0.decode(state)

    return {
      config: r0
    }
  }
}

// @peartube/set-seeding-config-response
const encoding59 = encoding10

// @peartube/pin-channel-request
const encoding60 = encoding28

// @peartube/pin-channel-response
const encoding61 = encoding10

// @peartube/unpin-channel-request
const encoding62 = encoding28

// @peartube/unpin-channel-response
const encoding63 = encoding10

// @peartube/get-pinned-channels-request
const encoding64 = encoding0

// @peartube/get-pinned-channels-response.channels
const encoding65_0 = c.array(c.string)

// @peartube/get-pinned-channels-response
const encoding65 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.channels) encoding65_0.preencode(state, m.channels)
  },
  encode(state, m) {
    const flags = m.channels ? 1 : 0

    c.uint.encode(state, flags)

    if (m.channels) encoding65_0.encode(state, m.channels)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channels: (flags & 1) !== 0 ? encoding65_0.decode(state) : null
    }
  }
}

// @peartube/get-video-thumbnail-request
const encoding66 = encoding21

// @peartube/get-video-thumbnail-response
const encoding67 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.url) c.string.preencode(state, m.url)
    if (m.dataUrl) c.string.preencode(state, m.dataUrl)
  },
  encode(state, m) {
    const flags =
      (m.url ? 1 : 0) |
      (m.dataUrl ? 2 : 0) |
      (m.exists ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.url) c.string.encode(state, m.url)
    if (m.dataUrl) c.string.encode(state, m.dataUrl)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      url: (flags & 1) !== 0 ? c.string.decode(state) : null,
      dataUrl: (flags & 2) !== 0 ? c.string.decode(state) : null,
      exists: (flags & 4) !== 0
    }
  }
}

// @peartube/get-video-metadata-request
const encoding68 = encoding21

// @peartube/get-video-metadata-response.video
const encoding69_0 = encoding24_0

// @peartube/get-video-metadata-response
const encoding69 = {
  preencode(state, m) {
    encoding69_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding69_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding69_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/set-video-thumbnail-request
const encoding70 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.imageData)
    state.end++ // max flag is 1 so always one byte

    if (m.mimeType) c.string.preencode(state, m.mimeType)
  },
  encode(state, m) {
    const flags = m.mimeType ? 1 : 0

    c.string.encode(state, m.videoId)
    c.string.encode(state, m.imageData)
    c.uint.encode(state, flags)

    if (m.mimeType) c.string.encode(state, m.mimeType)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      imageData: r1,
      mimeType: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/set-video-thumbnail-from-file-request
const encoding71 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.filePath)
  },
  encode(state, m) {
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.filePath)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      videoId: r0,
      filePath: r1
    }
  }
}

// @peartube/set-video-thumbnail-from-file-response
const encoding72 = encoding10

// @peartube/set-video-thumbnail-response
const encoding73 = encoding10

// @peartube/status
const encoding74 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.blobServerPort) c.uint.preencode(state, m.blobServerPort)
  },
  encode(state, m) {
    const flags =
      (m.ready ? 1 : 0) |
      (m.hasIdentity ? 2 : 0) |
      (m.blobServerPort ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.blobServerPort) c.uint.encode(state, m.blobServerPort)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      ready: (flags & 1) !== 0,
      hasIdentity: (flags & 2) !== 0,
      blobServerPort: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-status-request
const encoding75 = encoding0

// @peartube/get-status-response.status
const encoding76_0 = c.frame(encoding74)

// @peartube/get-status-response
const encoding76 = {
  preencode(state, m) {
    encoding76_0.preencode(state, m.status)
  },
  encode(state, m) {
    encoding76_0.encode(state, m.status)
  },
  decode(state) {
    const r0 = encoding76_0.decode(state)

    return {
      status: r0
    }
  }
}

// @peartube/pick-video-file-request
const encoding77 = encoding0

// @peartube/pick-video-file-response
const encoding78 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.filePath) c.string.preencode(state, m.filePath)
    if (m.name) c.string.preencode(state, m.name)
    if (m.size) c.uint.preencode(state, m.size)
  },
  encode(state, m) {
    const flags =
      (m.filePath ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.size ? 4 : 0) |
      (m.cancelled ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.filePath) c.string.encode(state, m.filePath)
    if (m.name) c.string.encode(state, m.name)
    if (m.size) c.uint.encode(state, m.size)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      filePath: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      size: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      cancelled: (flags & 8) !== 0
    }
  }
}

// @peartube/pick-image-file-request
const encoding79 = encoding0

// @peartube/pick-image-file-response
const encoding80 = {
  preencode(state, m) {
    state.end++ // max flag is 16 so always one byte

    if (m.filePath) c.string.preencode(state, m.filePath)
    if (m.name) c.string.preencode(state, m.name)
    if (m.size) c.uint.preencode(state, m.size)
    if (m.dataUrl) c.string.preencode(state, m.dataUrl)
  },
  encode(state, m) {
    const flags =
      (m.filePath ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.size ? 4 : 0) |
      (m.dataUrl ? 8 : 0) |
      (m.cancelled ? 16 : 0)

    c.uint.encode(state, flags)

    if (m.filePath) c.string.encode(state, m.filePath)
    if (m.name) c.string.encode(state, m.name)
    if (m.size) c.uint.encode(state, m.size)
    if (m.dataUrl) c.string.encode(state, m.dataUrl)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      filePath: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      size: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      dataUrl: (flags & 8) !== 0 ? c.string.decode(state) : null,
      cancelled: (flags & 16) !== 0
    }
  }
}

// @peartube/get-blob-server-port-request
const encoding81 = encoding0

// @peartube/get-blob-server-port-response
const encoding82 = {
  preencode(state, m) {
    c.uint.preencode(state, m.port)
  },
  encode(state, m) {
    c.uint.encode(state, m.port)
  },
  decode(state) {
    const r0 = c.uint.decode(state)

    return {
      port: r0
    }
  }
}

// @peartube/event-ready
const encoding83 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.blobServerPort) c.uint.preencode(state, m.blobServerPort)
  },
  encode(state, m) {
    const flags = m.blobServerPort ? 1 : 0

    c.uint.encode(state, flags)

    if (m.blobServerPort) c.uint.encode(state, m.blobServerPort)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      blobServerPort: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-error
const encoding84 = encoding1

// @peartube/event-upload-progress
const encoding85 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.uint.preencode(state, m.progress)
    state.end++ // max flag is 8 so always one byte

    if (m.bytesUploaded) c.uint.preencode(state, m.bytesUploaded)
    if (m.totalBytes) c.uint.preencode(state, m.totalBytes)
    if (version >= 8 && m.speed) c.uint.preencode(state, m.speed)
    if (version >= 8 && m.eta) c.uint.preencode(state, m.eta)
  },
  encode(state, m) {
    const flags =
      (m.bytesUploaded ? 1 : 0) |
      (m.totalBytes ? 2 : 0) |
      ((version >= 8 && m.speed) ? 4 : 0) |
      ((version >= 8 && m.eta) ? 8 : 0)

    c.string.encode(state, m.videoId)
    c.uint.encode(state, m.progress)
    c.uint.encode(state, flags)

    if (m.bytesUploaded) c.uint.encode(state, m.bytesUploaded)
    if (m.totalBytes) c.uint.encode(state, m.totalBytes)
    if (version >= 8 && m.speed) c.uint.encode(state, m.speed)
    if (version >= 8 && m.eta) c.uint.encode(state, m.eta)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      progress: r1,
      bytesUploaded: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      totalBytes: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      speed: (version >= 8 && (flags & 4) !== 0) ? c.uint.decode(state) : 0,
      eta: (version >= 8 && (flags & 8) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-feed-update
const encoding86 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.action)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.action)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      channelKey: r0,
      action: r1
    }
  }
}

// @peartube/event-log
const encoding87 = {
  preencode(state, m) {
    c.string.preencode(state, m.level)
    c.string.preencode(state, m.message)
    state.end++ // max flag is 1 so always one byte

    if (m.timestamp) c.uint.preencode(state, m.timestamp)
  },
  encode(state, m) {
    const flags = m.timestamp ? 1 : 0

    c.string.encode(state, m.level)
    c.string.encode(state, m.message)
    c.uint.encode(state, flags)

    if (m.timestamp) c.uint.encode(state, m.timestamp)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      level: r0,
      message: r1,
      timestamp: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-video-stats.stats
const encoding88_0 = encoding53_0

// @peartube/event-video-stats
const encoding88 = {
  preencode(state, m) {
    encoding88_0.preencode(state, m.stats)
  },
  encode(state, m) {
    encoding88_0.encode(state, m.stats)
  },
  decode(state) {
    const r0 = encoding88_0.decode(state)

    return {
      stats: r0
    }
  }
}

// @peartube/download-video-request
const encoding89 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.destPath)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.destPath)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      destPath: r2
    }
  }
}

// @peartube/download-video-response
const encoding90 = {
  preencode(state, m) {
    state.end++ // max flag is 16 so always one byte

    if (version >= 2 && m.filePath) c.string.preencode(state, m.filePath)
    if (version >= 2 && m.size) c.uint.preencode(state, m.size)
    if (version >= 2 && m.error) c.string.preencode(state, m.error)
    if (version >= 4 && m.data) c.string.preencode(state, m.data)
  },
  encode(state, m) {
    const flags =
      ((version >= 2 && m.success) ? 1 : 0) |
      ((version >= 2 && m.filePath) ? 2 : 0) |
      ((version >= 2 && m.size) ? 4 : 0) |
      ((version >= 2 && m.error) ? 8 : 0) |
      ((version >= 4 && m.data) ? 16 : 0)

    c.uint.encode(state, flags)

    if (version >= 2 && m.filePath) c.string.encode(state, m.filePath)
    if (version >= 2 && m.size) c.uint.encode(state, m.size)
    if (version >= 2 && m.error) c.string.encode(state, m.error)
    if (version >= 4 && m.data) c.string.encode(state, m.data)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 2 && (flags & 1) !== 0),
      filePath: (version >= 2 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      size: (version >= 2 && (flags & 4) !== 0) ? c.uint.decode(state) : 0,
      error: (version >= 2 && (flags & 8) !== 0) ? c.string.decode(state) : null,
      data: (version >= 4 && (flags & 16) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/delete-video-request
const encoding91 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
  },
  encode(state, m) {
    c.string.encode(state, m.videoId)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      videoId: r0
    }
  }
}

// @peartube/delete-video-response
const encoding92 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (version >= 5 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 5 && m.success) ? 1 : 0) |
      ((version >= 5 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)

    if (version >= 5 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 5 && (flags & 1) !== 0),
      error: (version >= 5 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-storage-stats-request
const encoding93 = encoding0

// @peartube/get-storage-stats-response
const encoding94 = {
  preencode(state, m) {
    c.uint.preencode(state, m.usedBytes)
    c.uint.preencode(state, m.maxBytes)
    c.string.preencode(state, m.usedGB)
    c.uint.preencode(state, m.maxGB)
    c.uint.preencode(state, m.seedCount)
    c.uint.preencode(state, m.pinnedCount)
  },
  encode(state, m) {
    c.uint.encode(state, m.usedBytes)
    c.uint.encode(state, m.maxBytes)
    c.string.encode(state, m.usedGB)
    c.uint.encode(state, m.maxGB)
    c.uint.encode(state, m.seedCount)
    c.uint.encode(state, m.pinnedCount)
  },
  decode(state) {
    const r0 = c.uint.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.string.decode(state)
    const r3 = c.uint.decode(state)
    const r4 = c.uint.decode(state)
    const r5 = c.uint.decode(state)

    return {
      usedBytes: r0,
      maxBytes: r1,
      usedGB: r2,
      maxGB: r3,
      seedCount: r4,
      pinnedCount: r5
    }
  }
}

// @peartube/set-storage-limit-request
const encoding95 = {
  preencode(state, m) {
    c.uint.preencode(state, m.maxGB)
  },
  encode(state, m) {
    c.uint.encode(state, m.maxGB)
  },
  decode(state) {
    const r0 = c.uint.decode(state)

    return {
      maxGB: r0
    }
  }
}

// @peartube/set-storage-limit-response
const encoding96 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = (version >= 6 && m.success) ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 6 && (flags & 1) !== 0)
    }
  }
}

// @peartube/clear-cache-request
const encoding97 = encoding0

// @peartube/clear-cache-response
const encoding98 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (version >= 6 && m.clearedBytes) c.uint.preencode(state, m.clearedBytes)
  },
  encode(state, m) {
    const flags =
      ((version >= 6 && m.success) ? 1 : 0) |
      ((version >= 6 && m.clearedBytes) ? 2 : 0)

    c.uint.encode(state, flags)

    if (version >= 6 && m.clearedBytes) c.uint.encode(state, m.clearedBytes)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 6 && (flags & 1) !== 0),
      clearedBytes: (version >= 6 && (flags & 2) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/unpublish-from-feed-request
const encoding99 = encoding0

// @peartube/unpublish-from-feed-response
const encoding100 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = (version >= 7 && m.success) ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 7 && (flags & 1) !== 0)
    }
  }
}

// @peartube/is-channel-published-request
const encoding101 = encoding0

// @peartube/is-channel-published-response
const encoding102 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = (version >= 7 && m.published) ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      published: (version >= 7 && (flags & 1) !== 0)
    }
  }
}

// @peartube/device
const encoding103 = {
  preencode(state, m) {
    c.string.preencode(state, m.keyHex)
    state.end++ // max flag is 8 so always one byte

    if (version >= 9 && m.role) c.string.preencode(state, m.role)
    if (version >= 9 && m.deviceName) c.string.preencode(state, m.deviceName)
    if (version >= 9 && m.addedAt) c.uint.preencode(state, m.addedAt)
    if (version >= 9 && m.blobDriveKey) c.string.preencode(state, m.blobDriveKey)
  },
  encode(state, m) {
    const flags =
      ((version >= 9 && m.role) ? 1 : 0) |
      ((version >= 9 && m.deviceName) ? 2 : 0) |
      ((version >= 9 && m.addedAt) ? 4 : 0) |
      ((version >= 9 && m.blobDriveKey) ? 8 : 0)

    c.string.encode(state, m.keyHex)
    c.uint.encode(state, flags)

    if (version >= 9 && m.role) c.string.encode(state, m.role)
    if (version >= 9 && m.deviceName) c.string.encode(state, m.deviceName)
    if (version >= 9 && m.addedAt) c.uint.encode(state, m.addedAt)
    if (version >= 9 && m.blobDriveKey) c.string.encode(state, m.blobDriveKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      keyHex: r0,
      role: (version >= 9 && (flags & 1) !== 0) ? c.string.decode(state) : null,
      deviceName: (version >= 9 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      addedAt: (version >= 9 && (flags & 4) !== 0) ? c.uint.decode(state) : 0,
      blobDriveKey: (version >= 9 && (flags & 8) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/create-device-invite-request
const encoding104 = encoding28

// @peartube/create-device-invite-response
const encoding105 = {
  preencode(state, m) {
    c.string.preencode(state, m.inviteCode)
  },
  encode(state, m) {
    c.string.encode(state, m.inviteCode)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      inviteCode: r0
    }
  }
}

// @peartube/pair-device-request
const encoding106 = {
  preencode(state, m) {
    c.string.preencode(state, m.inviteCode)
    state.end++ // max flag is 1 so always one byte

    if (version >= 9 && m.deviceName) c.string.preencode(state, m.deviceName)
  },
  encode(state, m) {
    const flags = (version >= 9 && m.deviceName) ? 1 : 0

    c.string.encode(state, m.inviteCode)
    c.uint.encode(state, flags)

    if (version >= 9 && m.deviceName) c.string.encode(state, m.deviceName)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      inviteCode: r0,
      deviceName: (version >= 9 && (flags & 1) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/pair-device-response
const encoding107 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte
    c.string.preencode(state, m.channelKey)

    if (version >= 10 && m.syncState) c.string.preencode(state, m.syncState)
    if (version >= 10 && m.videoCount) c.uint.preencode(state, m.videoCount)
  },
  encode(state, m) {
    const flags =
      ((version >= 9 && m.success) ? 1 : 0) |
      ((version >= 10 && m.syncState) ? 2 : 0) |
      ((version >= 10 && m.videoCount) ? 4 : 0)

    c.uint.encode(state, flags)
    c.string.encode(state, m.channelKey)

    if (version >= 10 && m.syncState) c.string.encode(state, m.syncState)
    if (version >= 10 && m.videoCount) c.uint.encode(state, m.videoCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 9 && (flags & 1) !== 0),
      channelKey: c.string.decode(state),
      syncState: (version >= 10 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      videoCount: (version >= 10 && (flags & 4) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/list-devices-request
const encoding108 = encoding28

// @peartube/list-devices-response.devices
const encoding109_0 = c.array(c.frame(encoding103))

// @peartube/list-devices-response
const encoding109 = {
  preencode(state, m) {
    encoding109_0.preencode(state, m.devices)
  },
  encode(state, m) {
    encoding109_0.encode(state, m.devices)
  },
  decode(state) {
    const r0 = encoding109_0.decode(state)

    return {
      devices: r0
    }
  }
}

// @peartube/retry-sync-channel-request
const encoding110 = encoding28

// @peartube/retry-sync-channel-response
const encoding111 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (version >= 10 && m.state) c.string.preencode(state, m.state)
    if (version >= 10 && m.videoCount) c.uint.preencode(state, m.videoCount)
  },
  encode(state, m) {
    const flags =
      ((version >= 10 && m.success) ? 1 : 0) |
      ((version >= 10 && m.state) ? 2 : 0) |
      ((version >= 10 && m.videoCount) ? 4 : 0)

    c.uint.encode(state, flags)

    if (version >= 10 && m.state) c.string.encode(state, m.state)
    if (version >= 10 && m.videoCount) c.uint.encode(state, m.videoCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 10 && (flags & 1) !== 0),
      state: (version >= 10 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      videoCount: (version >= 10 && (flags & 4) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/search-result
const encoding112 = {
  preencode(state, m) {
    c.string.preencode(state, m.id)
    state.end++ // max flag is 2 so always one byte

    if (version >= 11 && m.score) c.string.preencode(state, m.score)
    if (version >= 11 && m.metadata) c.string.preencode(state, m.metadata)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.score) ? 1 : 0) |
      ((version >= 11 && m.metadata) ? 2 : 0)

    c.string.encode(state, m.id)
    c.uint.encode(state, flags)

    if (version >= 11 && m.score) c.string.encode(state, m.score)
    if (version >= 11 && m.metadata) c.string.encode(state, m.metadata)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      id: r0,
      score: (version >= 11 && (flags & 1) !== 0) ? c.string.decode(state) : null,
      metadata: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/search-videos-request
const encoding113 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.query)
    state.end++ // max flag is 2 so always one byte

    if (version >= 11 && m.topK) c.uint.preencode(state, m.topK)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.topK) ? 1 : 0) |
      ((version >= 11 && m.federated) ? 2 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.query)
    c.uint.encode(state, flags)

    if (version >= 11 && m.topK) c.uint.encode(state, m.topK)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      query: r1,
      topK: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      federated: (version >= 11 && (flags & 2) !== 0)
    }
  }
}

// @peartube/search-videos-response.results
const encoding114_0 = c.array(c.frame(encoding112))

// @peartube/search-videos-response
const encoding114 = {
  preencode(state, m) {
    encoding114_0.preencode(state, m.results)
  },
  encode(state, m) {
    encoding114_0.encode(state, m.results)
  },
  decode(state) {
    const r0 = encoding114_0.decode(state)

    return {
      results: r0
    }
  }
}

// @peartube/index-video-vectors-request
const encoding115 = encoding21

// @peartube/index-video-vectors-response
const encoding116 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (version >= 11 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.success) ? 1 : 0) |
      ((version >= 11 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)

    if (version >= 11 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 11 && (flags & 1) !== 0),
      error: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/comment
const encoding117 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    c.string.preencode(state, m.text)
    c.string.preencode(state, m.authorKeyHex)
    state.end++ // max flag is 2 so always one byte

    if (version >= 11 && m.timestamp) c.uint.preencode(state, m.timestamp)
    if (version >= 11 && m.parentId) c.string.preencode(state, m.parentId)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.timestamp) ? 1 : 0) |
      ((version >= 11 && m.parentId) ? 2 : 0)

    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.string.encode(state, m.text)
    c.string.encode(state, m.authorKeyHex)
    c.uint.encode(state, flags)

    if (version >= 11 && m.timestamp) c.uint.encode(state, m.timestamp)
    if (version >= 11 && m.parentId) c.string.encode(state, m.parentId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const r3 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      commentId: r1,
      text: r2,
      authorKeyHex: r3,
      timestamp: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      parentId: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/add-comment-request
const encoding118 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.text)
    state.end++ // max flag is 1 so always one byte

    if (version >= 11 && m.parentId) c.string.preencode(state, m.parentId)
  },
  encode(state, m) {
    const flags = (version >= 11 && m.parentId) ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.text)
    c.uint.encode(state, flags)

    if (version >= 11 && m.parentId) c.string.encode(state, m.parentId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      text: r2,
      parentId: (version >= 11 && (flags & 1) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/add-comment-response
const encoding119 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (version >= 11 && m.commentId) c.string.preencode(state, m.commentId)
    if (version >= 11 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.success) ? 1 : 0) |
      ((version >= 11 && m.commentId) ? 2 : 0) |
      ((version >= 11 && m.error) ? 4 : 0)

    c.uint.encode(state, flags)

    if (version >= 11 && m.commentId) c.string.encode(state, m.commentId)
    if (version >= 11 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 11 && (flags & 1) !== 0),
      commentId: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      error: (version >= 11 && (flags & 4) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/list-comments-request
const encoding120 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 2 so always one byte

    if (version >= 11 && m.page) c.uint.preencode(state, m.page)
    if (version >= 11 && m.limit) c.uint.preencode(state, m.limit)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.page) ? 1 : 0) |
      ((version >= 11 && m.limit) ? 2 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (version >= 11 && m.page) c.uint.encode(state, m.page)
    if (version >= 11 && m.limit) c.uint.encode(state, m.limit)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      page: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      limit: (version >= 11 && (flags & 2) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/list-comments-response.comments
const encoding121_1 = c.array(c.frame(encoding117))

// @peartube/list-comments-response
const encoding121 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte
    encoding121_1.preencode(state, m.comments)

    if (version >= 11 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.success) ? 1 : 0) |
      ((version >= 11 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)
    encoding121_1.encode(state, m.comments)

    if (version >= 11 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 11 && (flags & 1) !== 0),
      comments: encoding121_1.decode(state),
      error: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/hide-comment-request
const encoding122 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      commentId: r2
    }
  }
}

// @peartube/hide-comment-response
const encoding123 = encoding116

// @peartube/remove-comment-request
const encoding124 = encoding122

// @peartube/remove-comment-response
const encoding125 = encoding116

// @peartube/reaction-count
const encoding126 = {
  preencode(state, m) {
    c.string.preencode(state, m.reactionType)
    c.uint.preencode(state, m.count)
  },
  encode(state, m) {
    c.string.encode(state, m.reactionType)
    c.uint.encode(state, m.count)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)

    return {
      reactionType: r0,
      count: r1
    }
  }
}

// @peartube/add-reaction-request
const encoding127 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.reactionType)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.reactionType)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      reactionType: r2
    }
  }
}

// @peartube/add-reaction-response
const encoding128 = encoding116

// @peartube/remove-reaction-request
const encoding129 = encoding21

// @peartube/remove-reaction-response
const encoding130 = encoding116

// @peartube/get-reactions-request
const encoding131 = encoding21

// @peartube/get-reactions-response.counts
const encoding132_1 = c.array(c.frame(encoding126))

// @peartube/get-reactions-response
const encoding132 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte
    encoding132_1.preencode(state, m.counts)

    if (version >= 11 && m.userReaction) c.string.preencode(state, m.userReaction)
    if (version >= 11 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.success) ? 1 : 0) |
      ((version >= 11 && m.userReaction) ? 2 : 0) |
      ((version >= 11 && m.error) ? 4 : 0)

    c.uint.encode(state, flags)
    encoding132_1.encode(state, m.counts)

    if (version >= 11 && m.userReaction) c.string.encode(state, m.userReaction)
    if (version >= 11 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 11 && (flags & 1) !== 0),
      counts: encoding132_1.decode(state),
      userReaction: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      error: (version >= 11 && (flags & 4) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/log-watch-event-request
const encoding133 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 4 so always one byte

    if (version >= 11 && m.duration) c.uint.preencode(state, m.duration)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.duration) ? 1 : 0) |
      ((version >= 11 && m.completed) ? 2 : 0) |
      ((version >= 11 && m.share) ? 4 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (version >= 11 && m.duration) c.uint.encode(state, m.duration)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      duration: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      completed: (version >= 11 && (flags & 2) !== 0),
      share: (version >= 11 && (flags & 4) !== 0)
    }
  }
}

// @peartube/log-watch-event-response
const encoding134 = encoding116

// @peartube/recommendation
const encoding135 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 2 so always one byte

    if (version >= 11 && m.score) c.string.preencode(state, m.score)
    if (version >= 11 && m.reason) c.string.preencode(state, m.reason)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.score) ? 1 : 0) |
      ((version >= 11 && m.reason) ? 2 : 0)

    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (version >= 11 && m.score) c.string.encode(state, m.score)
    if (version >= 11 && m.reason) c.string.encode(state, m.reason)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      score: (version >= 11 && (flags & 1) !== 0) ? c.string.decode(state) : null,
      reason: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-recommendations-request
const encoding136 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 1 so always one byte

    if (version >= 11 && m.limit) c.uint.preencode(state, m.limit)
  },
  encode(state, m) {
    const flags = (version >= 11 && m.limit) ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (version >= 11 && m.limit) c.uint.encode(state, m.limit)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      limit: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-recommendations-response.recommendations
const encoding137_1 = c.array(c.frame(encoding135))

// @peartube/get-recommendations-response
const encoding137 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte
    encoding137_1.preencode(state, m.recommendations)

    if (version >= 11 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.success) ? 1 : 0) |
      ((version >= 11 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)
    encoding137_1.encode(state, m.recommendations)

    if (version >= 11 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 11 && (flags & 1) !== 0),
      recommendations: encoding137_1.decode(state),
      error: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-video-recommendations-request
const encoding138 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 1 so always one byte

    if (version >= 11 && m.limit) c.uint.preencode(state, m.limit)
  },
  encode(state, m) {
    const flags = (version >= 11 && m.limit) ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (version >= 11 && m.limit) c.uint.encode(state, m.limit)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      limit: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-video-recommendations-response.recommendations
const encoding139_1 = encoding137_1

// @peartube/get-video-recommendations-response
const encoding139 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte
    encoding139_1.preencode(state, m.recommendations)

    if (version >= 11 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.success) ? 1 : 0) |
      ((version >= 11 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)
    encoding139_1.encode(state, m.recommendations)

    if (version >= 11 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 11 && (flags & 1) !== 0),
      recommendations: encoding139_1.decode(state),
      error: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-base
const encoding140 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
  },
  encode(state, m) {
    const flags = (version >= 11 && m.schemaVersion) ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-update-channel
const encoding141 = {
  preencode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.key) ? 2 : 0) |
      ((version >= 11 && m.name) ? 4 : 0) |
      ((version >= 11 && m.description) ? 8 : 0) |
      ((version >= 11 && m.avatar) ? 16 : 0) |
      ((version >= 11 && m.updatedAt) ? 32 : 0) |
      ((version >= 11 && m.updatedBy) ? 64 : 0) |
      ((version >= 11 && m.createdAt) ? 128 : 0) |
      ((version >= 11 && m.createdBy) ? 256 : 0)

    c.string.preencode(state, m.type)
    c.uint.preencode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    if (version >= 11 && m.key) c.string.preencode(state, m.key)
    if (version >= 11 && m.name) c.string.preencode(state, m.name)
    if (version >= 11 && m.description) c.string.preencode(state, m.description)
    if (version >= 11 && m.avatar) c.string.preencode(state, m.avatar)
    if (version >= 11 && m.updatedAt) c.uint.preencode(state, m.updatedAt)
    if (version >= 11 && m.updatedBy) c.string.preencode(state, m.updatedBy)
    if (version >= 11 && m.createdAt) c.uint.preencode(state, m.createdAt)
    if (version >= 11 && m.createdBy) c.string.preencode(state, m.createdBy)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.key) ? 2 : 0) |
      ((version >= 11 && m.name) ? 4 : 0) |
      ((version >= 11 && m.description) ? 8 : 0) |
      ((version >= 11 && m.avatar) ? 16 : 0) |
      ((version >= 11 && m.updatedAt) ? 32 : 0) |
      ((version >= 11 && m.updatedBy) ? 64 : 0) |
      ((version >= 11 && m.createdAt) ? 128 : 0) |
      ((version >= 11 && m.createdBy) ? 256 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    if (version >= 11 && m.key) c.string.encode(state, m.key)
    if (version >= 11 && m.name) c.string.encode(state, m.name)
    if (version >= 11 && m.description) c.string.encode(state, m.description)
    if (version >= 11 && m.avatar) c.string.encode(state, m.avatar)
    if (version >= 11 && m.updatedAt) c.uint.encode(state, m.updatedAt)
    if (version >= 11 && m.updatedBy) c.string.encode(state, m.updatedBy)
    if (version >= 11 && m.createdAt) c.uint.encode(state, m.createdAt)
    if (version >= 11 && m.createdBy) c.string.encode(state, m.createdBy)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      key: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      name: (version >= 11 && (flags & 4) !== 0) ? c.string.decode(state) : null,
      description: (version >= 11 && (flags & 8) !== 0) ? c.string.decode(state) : null,
      avatar: (version >= 11 && (flags & 16) !== 0) ? c.string.decode(state) : null,
      updatedAt: (version >= 11 && (flags & 32) !== 0) ? c.uint.decode(state) : 0,
      updatedBy: (version >= 11 && (flags & 64) !== 0) ? c.string.decode(state) : null,
      createdAt: (version >= 11 && (flags & 128) !== 0) ? c.uint.decode(state) : 0,
      createdBy: (version >= 11 && (flags & 256) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-add-video
const encoding142 = {
  preencode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.description) ? 2 : 0) |
      ((version >= 11 && m.path) ? 4 : 0) |
      ((version >= 11 && m.duration) ? 8 : 0) |
      ((version >= 11 && m.thumbnail) ? 16 : 0) |
      ((version >= 11 && m.blobDriveKey) ? 32 : 0) |
      ((version >= 11 && m.mimeType) ? 64 : 0) |
      ((version >= 11 && m.size) ? 128 : 0) |
      ((version >= 11 && m.uploadedAt) ? 256 : 0) |
      ((version >= 11 && m.uploadedBy) ? 512 : 0) |
      ((version >= 11 && m.category) ? 1024 : 0) |
      ((version >= 11 && m.views) ? 2048 : 0)

    c.string.preencode(state, m.type)
    c.uint.preencode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.id)
    c.string.preencode(state, m.title)
    if (version >= 11 && m.description) c.string.preencode(state, m.description)
    if (version >= 11 && m.path) c.string.preencode(state, m.path)
    if (version >= 11 && m.duration) c.uint.preencode(state, m.duration)
    if (version >= 11 && m.thumbnail) c.string.preencode(state, m.thumbnail)
    if (version >= 11 && m.blobDriveKey) c.string.preencode(state, m.blobDriveKey)
    if (version >= 11 && m.mimeType) c.string.preencode(state, m.mimeType)
    if (version >= 11 && m.size) c.uint.preencode(state, m.size)
    if (version >= 11 && m.uploadedAt) c.uint.preencode(state, m.uploadedAt)
    if (version >= 11 && m.uploadedBy) c.string.preencode(state, m.uploadedBy)
    if (version >= 11 && m.category) c.string.preencode(state, m.category)
    if (version >= 11 && m.views) c.uint.preencode(state, m.views)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.description) ? 2 : 0) |
      ((version >= 11 && m.path) ? 4 : 0) |
      ((version >= 11 && m.duration) ? 8 : 0) |
      ((version >= 11 && m.thumbnail) ? 16 : 0) |
      ((version >= 11 && m.blobDriveKey) ? 32 : 0) |
      ((version >= 11 && m.mimeType) ? 64 : 0) |
      ((version >= 11 && m.size) ? 128 : 0) |
      ((version >= 11 && m.uploadedAt) ? 256 : 0) |
      ((version >= 11 && m.uploadedBy) ? 512 : 0) |
      ((version >= 11 && m.category) ? 1024 : 0) |
      ((version >= 11 && m.views) ? 2048 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.id)
    c.string.encode(state, m.title)
    if (version >= 11 && m.description) c.string.encode(state, m.description)
    if (version >= 11 && m.path) c.string.encode(state, m.path)
    if (version >= 11 && m.duration) c.uint.encode(state, m.duration)
    if (version >= 11 && m.thumbnail) c.string.encode(state, m.thumbnail)
    if (version >= 11 && m.blobDriveKey) c.string.encode(state, m.blobDriveKey)
    if (version >= 11 && m.mimeType) c.string.encode(state, m.mimeType)
    if (version >= 11 && m.size) c.uint.encode(state, m.size)
    if (version >= 11 && m.uploadedAt) c.uint.encode(state, m.uploadedAt)
    if (version >= 11 && m.uploadedBy) c.string.encode(state, m.uploadedBy)
    if (version >= 11 && m.category) c.string.encode(state, m.category)
    if (version >= 11 && m.views) c.uint.encode(state, m.views)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      id: c.string.decode(state),
      title: c.string.decode(state),
      description: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      path: (version >= 11 && (flags & 4) !== 0) ? c.string.decode(state) : null,
      duration: (version >= 11 && (flags & 8) !== 0) ? c.uint.decode(state) : 0,
      thumbnail: (version >= 11 && (flags & 16) !== 0) ? c.string.decode(state) : null,
      blobDriveKey: (version >= 11 && (flags & 32) !== 0) ? c.string.decode(state) : null,
      mimeType: (version >= 11 && (flags & 64) !== 0) ? c.string.decode(state) : null,
      size: (version >= 11 && (flags & 128) !== 0) ? c.uint.decode(state) : 0,
      uploadedAt: (version >= 11 && (flags & 256) !== 0) ? c.uint.decode(state) : 0,
      uploadedBy: (version >= 11 && (flags & 512) !== 0) ? c.string.decode(state) : null,
      category: (version >= 11 && (flags & 1024) !== 0) ? c.string.decode(state) : null,
      views: (version >= 11 && (flags & 2048) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-update-video
const encoding143 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 64 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.id)
    if (version >= 11 && m.title) c.string.preencode(state, m.title)
    if (version >= 11 && m.description) c.string.preencode(state, m.description)
    if (version >= 11 && m.thumbnail) c.string.preencode(state, m.thumbnail)
    if (version >= 11 && m.category) c.string.preencode(state, m.category)
    if (version >= 11 && m.updatedAt) c.uint.preencode(state, m.updatedAt)
    if (version >= 11 && m.updatedBy) c.string.preencode(state, m.updatedBy)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.title) ? 2 : 0) |
      ((version >= 11 && m.description) ? 4 : 0) |
      ((version >= 11 && m.thumbnail) ? 8 : 0) |
      ((version >= 11 && m.category) ? 16 : 0) |
      ((version >= 11 && m.updatedAt) ? 32 : 0) |
      ((version >= 11 && m.updatedBy) ? 64 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.id)
    if (version >= 11 && m.title) c.string.encode(state, m.title)
    if (version >= 11 && m.description) c.string.encode(state, m.description)
    if (version >= 11 && m.thumbnail) c.string.encode(state, m.thumbnail)
    if (version >= 11 && m.category) c.string.encode(state, m.category)
    if (version >= 11 && m.updatedAt) c.uint.encode(state, m.updatedAt)
    if (version >= 11 && m.updatedBy) c.string.encode(state, m.updatedBy)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      id: c.string.decode(state),
      title: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      description: (version >= 11 && (flags & 4) !== 0) ? c.string.decode(state) : null,
      thumbnail: (version >= 11 && (flags & 8) !== 0) ? c.string.decode(state) : null,
      category: (version >= 11 && (flags & 16) !== 0) ? c.string.decode(state) : null,
      updatedAt: (version >= 11 && (flags & 32) !== 0) ? c.uint.decode(state) : 0,
      updatedBy: (version >= 11 && (flags & 64) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-delete-video
const encoding144 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.id)
  },
  encode(state, m) {
    const flags = (version >= 11 && m.schemaVersion) ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.id)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      id: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-add-writer
const encoding145 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 16 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.keyHex)
    if (version >= 11 && m.role) c.string.preencode(state, m.role)
    if (version >= 11 && m.deviceName) c.string.preencode(state, m.deviceName)
    if (version >= 11 && m.addedAt) c.uint.preencode(state, m.addedAt)
    if (version >= 11 && m.blobDriveKey) c.string.preencode(state, m.blobDriveKey)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.role) ? 2 : 0) |
      ((version >= 11 && m.deviceName) ? 4 : 0) |
      ((version >= 11 && m.addedAt) ? 8 : 0) |
      ((version >= 11 && m.blobDriveKey) ? 16 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.keyHex)
    if (version >= 11 && m.role) c.string.encode(state, m.role)
    if (version >= 11 && m.deviceName) c.string.encode(state, m.deviceName)
    if (version >= 11 && m.addedAt) c.uint.encode(state, m.addedAt)
    if (version >= 11 && m.blobDriveKey) c.string.encode(state, m.blobDriveKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      keyHex: c.string.decode(state),
      role: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      deviceName: (version >= 11 && (flags & 4) !== 0) ? c.string.decode(state) : null,
      addedAt: (version >= 11 && (flags & 8) !== 0) ? c.uint.decode(state) : 0,
      blobDriveKey: (version >= 11 && (flags & 16) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-upsert-writer
const encoding146 = encoding145

// @peartube/channel-op-remove-writer
const encoding147 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 2 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.keyHex)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.ban) ? 2 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.keyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      keyHex: c.string.decode(state),
      ban: (version >= 11 && (flags & 2) !== 0)
    }
  }
}

// @peartube/channel-op-add-invite
const encoding148 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 8 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.idHex)
    c.string.preencode(state, m.inviteZ32)
    if (version >= 11 && m.publicKeyHex) c.string.preencode(state, m.publicKeyHex)
    if (version >= 11 && m.expires) c.uint.preencode(state, m.expires)
    if (version >= 11 && m.createdAt) c.uint.preencode(state, m.createdAt)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.publicKeyHex) ? 2 : 0) |
      ((version >= 11 && m.expires) ? 4 : 0) |
      ((version >= 11 && m.createdAt) ? 8 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.idHex)
    c.string.encode(state, m.inviteZ32)
    if (version >= 11 && m.publicKeyHex) c.string.encode(state, m.publicKeyHex)
    if (version >= 11 && m.expires) c.uint.encode(state, m.expires)
    if (version >= 11 && m.createdAt) c.uint.encode(state, m.createdAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      idHex: c.string.decode(state),
      inviteZ32: c.string.decode(state),
      publicKeyHex: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      expires: (version >= 11 && (flags & 4) !== 0) ? c.uint.decode(state) : 0,
      createdAt: (version >= 11 && (flags & 8) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-delete-invite
const encoding149 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.idHex)
  },
  encode(state, m) {
    const flags = (version >= 11 && m.schemaVersion) ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.idHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      idHex: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-add-comment
const encoding150 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 4 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    c.string.preencode(state, m.text)
    c.string.preencode(state, m.authorKeyHex)
    if (version >= 11 && m.timestamp) c.uint.preencode(state, m.timestamp)
    if (version >= 11 && m.parentId) c.string.preencode(state, m.parentId)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.timestamp) ? 2 : 0) |
      ((version >= 11 && m.parentId) ? 4 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.string.encode(state, m.text)
    c.string.encode(state, m.authorKeyHex)
    if (version >= 11 && m.timestamp) c.uint.encode(state, m.timestamp)
    if (version >= 11 && m.parentId) c.string.encode(state, m.parentId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      commentId: c.string.decode(state),
      text: c.string.decode(state),
      authorKeyHex: c.string.decode(state),
      timestamp: (version >= 11 && (flags & 2) !== 0) ? c.uint.decode(state) : 0,
      parentId: (version >= 11 && (flags & 4) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-add-reaction
const encoding151 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 2 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.reactionType)
    c.string.preencode(state, m.authorKeyHex)
    if (version >= 11 && m.timestamp) c.uint.preencode(state, m.timestamp)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.timestamp) ? 2 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.reactionType)
    c.string.encode(state, m.authorKeyHex)
    if (version >= 11 && m.timestamp) c.uint.encode(state, m.timestamp)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      reactionType: c.string.decode(state),
      authorKeyHex: c.string.decode(state),
      timestamp: (version >= 11 && (flags & 2) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-remove-reaction
const encoding152 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.authorKeyHex)
  },
  encode(state, m) {
    const flags = (version >= 11 && m.schemaVersion) ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.authorKeyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      authorKeyHex: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-hide-comment
const encoding153 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    c.string.preencode(state, m.moderatorKeyHex)
  },
  encode(state, m) {
    const flags = (version >= 11 && m.schemaVersion) ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.string.encode(state, m.moderatorKeyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      commentId: c.string.decode(state),
      moderatorKeyHex: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-remove-comment
const encoding154 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 4 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    if (version >= 11 && m.moderatorKeyHex) c.string.preencode(state, m.moderatorKeyHex)
    if (version >= 11 && m.authorKeyHex) c.string.preencode(state, m.authorKeyHex)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.moderatorKeyHex) ? 2 : 0) |
      ((version >= 11 && m.authorKeyHex) ? 4 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    if (version >= 11 && m.moderatorKeyHex) c.string.encode(state, m.moderatorKeyHex)
    if (version >= 11 && m.authorKeyHex) c.string.encode(state, m.authorKeyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      commentId: c.string.decode(state),
      moderatorKeyHex: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      authorKeyHex: (version >= 11 && (flags & 4) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-add-vector-index
const encoding155 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 8 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    if (version >= 11 && m.vector) c.string.preencode(state, m.vector)
    if (version >= 11 && m.text) c.string.preencode(state, m.text)
    if (version >= 11 && m.metadata) c.string.preencode(state, m.metadata)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.vector) ? 2 : 0) |
      ((version >= 11 && m.text) ? 4 : 0) |
      ((version >= 11 && m.metadata) ? 8 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    if (version >= 11 && m.vector) c.string.encode(state, m.vector)
    if (version >= 11 && m.text) c.string.encode(state, m.text)
    if (version >= 11 && m.metadata) c.string.encode(state, m.metadata)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      vector: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      text: (version >= 11 && (flags & 4) !== 0) ? c.string.decode(state) : null,
      metadata: (version >= 11 && (flags & 8) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-log-watch-event
const encoding156 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 32 so always one byte

    if (version >= 11 && m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    if (version >= 11 && m.channelKey) c.string.preencode(state, m.channelKey)
    if (version >= 11 && m.watcherKeyHex) c.string.preencode(state, m.watcherKeyHex)
    if (version >= 11 && m.duration) c.uint.preencode(state, m.duration)
    if (version >= 11 && m.timestamp) c.uint.preencode(state, m.timestamp)
  },
  encode(state, m) {
    const flags =
      ((version >= 11 && m.schemaVersion) ? 1 : 0) |
      ((version >= 11 && m.channelKey) ? 2 : 0) |
      ((version >= 11 && m.watcherKeyHex) ? 4 : 0) |
      ((version >= 11 && m.duration) ? 8 : 0) |
      ((version >= 11 && m.completed) ? 16 : 0) |
      ((version >= 11 && m.timestamp) ? 32 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (version >= 11 && m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    if (version >= 11 && m.channelKey) c.string.encode(state, m.channelKey)
    if (version >= 11 && m.watcherKeyHex) c.string.encode(state, m.watcherKeyHex)
    if (version >= 11 && m.duration) c.uint.encode(state, m.duration)
    if (version >= 11 && m.timestamp) c.uint.encode(state, m.timestamp)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      channelKey: (version >= 11 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      watcherKeyHex: (version >= 11 && (flags & 4) !== 0) ? c.string.decode(state) : null,
      duration: (version >= 11 && (flags & 8) !== 0) ? c.uint.decode(state) : 0,
      completed: (version >= 11 && (flags & 16) !== 0),
      timestamp: (version >= 11 && (flags & 32) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-migrate-schema
const encoding157 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    c.uint.preencode(state, m.schemaVersion)
    c.uint.preencode(state, m.fromVersion)
    c.uint.preencode(state, m.toVersion)
    state.end++ // max flag is 1 so always one byte

    if (version >= 11 && m.migratedAt) c.uint.preencode(state, m.migratedAt)
  },
  encode(state, m) {
    const flags = (version >= 11 && m.migratedAt) ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, m.schemaVersion)
    c.uint.encode(state, m.fromVersion)
    c.uint.encode(state, m.toVersion)
    c.uint.encode(state, flags)

    if (version >= 11 && m.migratedAt) c.uint.encode(state, m.migratedAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.uint.decode(state)
    const r3 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: r1,
      fromVersion: r2,
      toVersion: r3,
      migratedAt: (version >= 11 && (flags & 1) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

function setVersion(v) {
  version = v
}

function encode(name, value, v = VERSION) {
  version = v
  return c.encode(getEncoding(name), value)
}

function decode(name, buffer, v = VERSION) {
  version = v
  return c.decode(getEncoding(name), buffer)
}

function getEnum(name) {
  switch (name) {
    default:
      throw new Error('Enum not found ' + name)
  }
}

function getEncoding(name) {
  switch (name) {
    case '@peartube/empty':
      return encoding0
    case '@peartube/error':
      return encoding1
    case '@peartube/identity':
      return encoding2
    case '@peartube/create-identity-request':
      return encoding3
    case '@peartube/create-identity-response':
      return encoding4
    case '@peartube/get-identity-request':
      return encoding5
    case '@peartube/get-identity-response':
      return encoding6
    case '@peartube/get-identities-request':
      return encoding7
    case '@peartube/get-identities-response':
      return encoding8
    case '@peartube/set-active-identity-request':
      return encoding9
    case '@peartube/set-active-identity-response':
      return encoding10
    case '@peartube/recover-identity-request':
      return encoding11
    case '@peartube/recover-identity-response':
      return encoding12
    case '@peartube/channel':
      return encoding13
    case '@peartube/get-channel-request':
      return encoding14
    case '@peartube/get-channel-response':
      return encoding15
    case '@peartube/update-channel-request':
      return encoding16
    case '@peartube/update-channel-response':
      return encoding17
    case '@peartube/video':
      return encoding18
    case '@peartube/list-videos-request':
      return encoding19
    case '@peartube/list-videos-response':
      return encoding20
    case '@peartube/get-video-url-request':
      return encoding21
    case '@peartube/get-video-url-response':
      return encoding22
    case '@peartube/get-video-data-request':
      return encoding23
    case '@peartube/get-video-data-response':
      return encoding24
    case '@peartube/upload-video-request':
      return encoding25
    case '@peartube/upload-video-response':
      return encoding26
    case '@peartube/subscription':
      return encoding27
    case '@peartube/subscribe-channel-request':
      return encoding28
    case '@peartube/subscribe-channel-response':
      return encoding29
    case '@peartube/unsubscribe-channel-request':
      return encoding30
    case '@peartube/unsubscribe-channel-response':
      return encoding31
    case '@peartube/get-subscriptions-request':
      return encoding32
    case '@peartube/get-subscriptions-response':
      return encoding33
    case '@peartube/join-channel-request':
      return encoding34
    case '@peartube/join-channel-response':
      return encoding35
    case '@peartube/feed-entry':
      return encoding36
    case '@peartube/get-public-feed-request':
      return encoding37
    case '@peartube/get-public-feed-response':
      return encoding38
    case '@peartube/refresh-feed-request':
      return encoding39
    case '@peartube/refresh-feed-response':
      return encoding40
    case '@peartube/submit-to-feed-request':
      return encoding41
    case '@peartube/submit-to-feed-response':
      return encoding42
    case '@peartube/hide-channel-request':
      return encoding43
    case '@peartube/hide-channel-response':
      return encoding44
    case '@peartube/get-channel-meta-request':
      return encoding45
    case '@peartube/get-channel-meta-response':
      return encoding46
    case '@peartube/get-swarm-status-request':
      return encoding47
    case '@peartube/get-swarm-status-response':
      return encoding48
    case '@peartube/prefetch-video-request':
      return encoding49
    case '@peartube/prefetch-video-response':
      return encoding50
    case '@peartube/video-stats':
      return encoding51
    case '@peartube/get-video-stats-request':
      return encoding52
    case '@peartube/get-video-stats-response':
      return encoding53
    case '@peartube/seeding-config':
      return encoding54
    case '@peartube/seeding-status':
      return encoding55
    case '@peartube/get-seeding-status-request':
      return encoding56
    case '@peartube/get-seeding-status-response':
      return encoding57
    case '@peartube/set-seeding-config-request':
      return encoding58
    case '@peartube/set-seeding-config-response':
      return encoding59
    case '@peartube/pin-channel-request':
      return encoding60
    case '@peartube/pin-channel-response':
      return encoding61
    case '@peartube/unpin-channel-request':
      return encoding62
    case '@peartube/unpin-channel-response':
      return encoding63
    case '@peartube/get-pinned-channels-request':
      return encoding64
    case '@peartube/get-pinned-channels-response':
      return encoding65
    case '@peartube/get-video-thumbnail-request':
      return encoding66
    case '@peartube/get-video-thumbnail-response':
      return encoding67
    case '@peartube/get-video-metadata-request':
      return encoding68
    case '@peartube/get-video-metadata-response':
      return encoding69
    case '@peartube/set-video-thumbnail-request':
      return encoding70
    case '@peartube/set-video-thumbnail-from-file-request':
      return encoding71
    case '@peartube/set-video-thumbnail-from-file-response':
      return encoding72
    case '@peartube/set-video-thumbnail-response':
      return encoding73
    case '@peartube/status':
      return encoding74
    case '@peartube/get-status-request':
      return encoding75
    case '@peartube/get-status-response':
      return encoding76
    case '@peartube/pick-video-file-request':
      return encoding77
    case '@peartube/pick-video-file-response':
      return encoding78
    case '@peartube/pick-image-file-request':
      return encoding79
    case '@peartube/pick-image-file-response':
      return encoding80
    case '@peartube/get-blob-server-port-request':
      return encoding81
    case '@peartube/get-blob-server-port-response':
      return encoding82
    case '@peartube/event-ready':
      return encoding83
    case '@peartube/event-error':
      return encoding84
    case '@peartube/event-upload-progress':
      return encoding85
    case '@peartube/event-feed-update':
      return encoding86
    case '@peartube/event-log':
      return encoding87
    case '@peartube/event-video-stats':
      return encoding88
    case '@peartube/download-video-request':
      return encoding89
    case '@peartube/download-video-response':
      return encoding90
    case '@peartube/delete-video-request':
      return encoding91
    case '@peartube/delete-video-response':
      return encoding92
    case '@peartube/get-storage-stats-request':
      return encoding93
    case '@peartube/get-storage-stats-response':
      return encoding94
    case '@peartube/set-storage-limit-request':
      return encoding95
    case '@peartube/set-storage-limit-response':
      return encoding96
    case '@peartube/clear-cache-request':
      return encoding97
    case '@peartube/clear-cache-response':
      return encoding98
    case '@peartube/unpublish-from-feed-request':
      return encoding99
    case '@peartube/unpublish-from-feed-response':
      return encoding100
    case '@peartube/is-channel-published-request':
      return encoding101
    case '@peartube/is-channel-published-response':
      return encoding102
    case '@peartube/device':
      return encoding103
    case '@peartube/create-device-invite-request':
      return encoding104
    case '@peartube/create-device-invite-response':
      return encoding105
    case '@peartube/pair-device-request':
      return encoding106
    case '@peartube/pair-device-response':
      return encoding107
    case '@peartube/list-devices-request':
      return encoding108
    case '@peartube/list-devices-response':
      return encoding109
    case '@peartube/retry-sync-channel-request':
      return encoding110
    case '@peartube/retry-sync-channel-response':
      return encoding111
    case '@peartube/search-result':
      return encoding112
    case '@peartube/search-videos-request':
      return encoding113
    case '@peartube/search-videos-response':
      return encoding114
    case '@peartube/index-video-vectors-request':
      return encoding115
    case '@peartube/index-video-vectors-response':
      return encoding116
    case '@peartube/comment':
      return encoding117
    case '@peartube/add-comment-request':
      return encoding118
    case '@peartube/add-comment-response':
      return encoding119
    case '@peartube/list-comments-request':
      return encoding120
    case '@peartube/list-comments-response':
      return encoding121
    case '@peartube/hide-comment-request':
      return encoding122
    case '@peartube/hide-comment-response':
      return encoding123
    case '@peartube/remove-comment-request':
      return encoding124
    case '@peartube/remove-comment-response':
      return encoding125
    case '@peartube/reaction-count':
      return encoding126
    case '@peartube/add-reaction-request':
      return encoding127
    case '@peartube/add-reaction-response':
      return encoding128
    case '@peartube/remove-reaction-request':
      return encoding129
    case '@peartube/remove-reaction-response':
      return encoding130
    case '@peartube/get-reactions-request':
      return encoding131
    case '@peartube/get-reactions-response':
      return encoding132
    case '@peartube/log-watch-event-request':
      return encoding133
    case '@peartube/log-watch-event-response':
      return encoding134
    case '@peartube/recommendation':
      return encoding135
    case '@peartube/get-recommendations-request':
      return encoding136
    case '@peartube/get-recommendations-response':
      return encoding137
    case '@peartube/get-video-recommendations-request':
      return encoding138
    case '@peartube/get-video-recommendations-response':
      return encoding139
    case '@peartube/channel-op-base':
      return encoding140
    case '@peartube/channel-op-update-channel':
      return encoding141
    case '@peartube/channel-op-add-video':
      return encoding142
    case '@peartube/channel-op-update-video':
      return encoding143
    case '@peartube/channel-op-delete-video':
      return encoding144
    case '@peartube/channel-op-add-writer':
      return encoding145
    case '@peartube/channel-op-upsert-writer':
      return encoding146
    case '@peartube/channel-op-remove-writer':
      return encoding147
    case '@peartube/channel-op-add-invite':
      return encoding148
    case '@peartube/channel-op-delete-invite':
      return encoding149
    case '@peartube/channel-op-add-comment':
      return encoding150
    case '@peartube/channel-op-add-reaction':
      return encoding151
    case '@peartube/channel-op-remove-reaction':
      return encoding152
    case '@peartube/channel-op-hide-comment':
      return encoding153
    case '@peartube/channel-op-remove-comment':
      return encoding154
    case '@peartube/channel-op-add-vector-index':
      return encoding155
    case '@peartube/channel-op-log-watch-event':
      return encoding156
    case '@peartube/channel-op-migrate-schema':
      return encoding157
    default:
      throw new Error('Encoder not found ' + name)
  }
}

function getStruct(name, v = VERSION) {
  const enc = getEncoding(name)
  return {
    preencode(state, m) {
      version = v
      enc.preencode(state, m)
    },
    encode(state, m) {
      version = v
      enc.encode(state, m)
    },
    decode(state) {
      version = v
      return enc.decode(state)
    }
  }
}

const resolveStruct = getStruct // compat

module.exports = {
  resolveStruct,
  getStruct,
  getEnum,
  getEncoding,
  encode,
  decode,
  setVersion,
  version
}
