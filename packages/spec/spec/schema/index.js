// This file is autogenerated by the hyperschema compiler
// Schema Version: 4
/* eslint-disable camelcase */
/* eslint-disable quotes */
/* eslint-disable space-before-function-paren */

const { c } = require('hyperschema/runtime')

const VERSION = 4

// eslint-disable-next-line no-unused-vars
let version = VERSION

// @peartube/empty
const encoding0 = {
  preencode(state, m) {

  },
  encode(state, m) {

  },
  decode(state) {
    return {
    }
  }
}

// @peartube/error
const encoding1 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.code) c.uint.preencode(state, m.code)
    c.string.preencode(state, m.message)
  },
  encode(state, m) {
    const flags = m.code ? 1 : 0

    c.uint.encode(state, flags)

    if (m.code) c.uint.encode(state, m.code)
    c.string.encode(state, m.message)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      code: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      message: c.string.decode(state)
    }
  }
}

// @peartube/identity
const encoding2 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
    state.end++ // max flag is 32 so always one byte

    if (m.driveKey) c.string.preencode(state, m.driveKey)
    if (m.name) c.string.preencode(state, m.name)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.seedPhrase) c.string.preencode(state, m.seedPhrase)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
  },
  encode(state, m) {
    const flags =
      (m.driveKey ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.avatar ? 4 : 0) |
      (m.seedPhrase ? 8 : 0) |
      (m.createdAt ? 16 : 0) |
      (m.isActive ? 32 : 0)

    c.string.encode(state, m.publicKey)
    c.uint.encode(state, flags)

    if (m.driveKey) c.string.encode(state, m.driveKey)
    if (m.name) c.string.encode(state, m.name)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.seedPhrase) c.string.encode(state, m.seedPhrase)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      publicKey: r0,
      driveKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null,
      seedPhrase: (flags & 8) !== 0 ? c.string.decode(state) : null,
      createdAt: (flags & 16) !== 0 ? c.uint.decode(state) : 0,
      isActive: (flags & 32) !== 0
    }
  }
}

// @peartube/create-identity-request
const encoding3 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.avatar) c.string.preencode(state, m.avatar)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.avatar ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.avatar) c.string.encode(state, m.avatar)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/create-identity-response.identity
const encoding4_0 = c.frame(encoding2)

// @peartube/create-identity-response
const encoding4 = {
  preencode(state, m) {
    encoding4_0.preencode(state, m.identity)
  },
  encode(state, m) {
    encoding4_0.encode(state, m.identity)
  },
  decode(state) {
    const r0 = encoding4_0.decode(state)

    return {
      identity: r0
    }
  }
}

// @peartube/get-identity-request
const encoding5 = encoding0

// @peartube/get-identity-response.identity
const encoding6_0 = encoding4_0

// @peartube/get-identity-response
const encoding6 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.identity) encoding6_0.preencode(state, m.identity)
  },
  encode(state, m) {
    const flags = m.identity ? 1 : 0

    c.uint.encode(state, flags)

    if (m.identity) encoding6_0.encode(state, m.identity)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      identity: (flags & 1) !== 0 ? encoding6_0.decode(state) : null
    }
  }
}

// @peartube/get-identities-request
const encoding7 = encoding0

// @peartube/get-identities-response.identities
const encoding8_0 = c.array(c.frame(encoding2))

// @peartube/get-identities-response
const encoding8 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.identities) encoding8_0.preencode(state, m.identities)
  },
  encode(state, m) {
    const flags = m.identities ? 1 : 0

    c.uint.encode(state, flags)

    if (m.identities) encoding8_0.encode(state, m.identities)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      identities: (flags & 1) !== 0 ? encoding8_0.decode(state) : null
    }
  }
}

// @peartube/set-active-identity-request
const encoding9 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
  },
  encode(state, m) {
    c.string.encode(state, m.publicKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      publicKey: r0
    }
  }
}

// @peartube/set-active-identity-response
const encoding10 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = m.success ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0
    }
  }
}

// @peartube/recover-identity-request
const encoding11 = {
  preencode(state, m) {
    c.string.preencode(state, m.seedPhrase)
  },
  encode(state, m) {
    c.string.encode(state, m.seedPhrase)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      seedPhrase: r0
    }
  }
}

// @peartube/recover-identity-response.identity
const encoding12_0 = encoding4_0

// @peartube/recover-identity-response
const encoding12 = {
  preencode(state, m) {
    encoding12_0.preencode(state, m.identity)
  },
  encode(state, m) {
    encoding12_0.encode(state, m.identity)
  },
  decode(state) {
    const r0 = encoding12_0.decode(state)

    return {
      identity: r0
    }
  }
}

// @peartube/channel
const encoding13 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
    state.end++ // max flag is 16 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
    if (m.subscriberCount) c.uint.preencode(state, m.subscriberCount)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.avatar ? 4 : 0) |
      (m.videoCount ? 8 : 0) |
      (m.subscriberCount ? 16 : 0)

    c.string.encode(state, m.publicKey)
    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
    if (m.subscriberCount) c.uint.encode(state, m.subscriberCount)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      publicKey: r0,
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      subscriberCount: (flags & 16) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-channel-request
const encoding14 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.publicKey) c.string.preencode(state, m.publicKey)
  },
  encode(state, m) {
    const flags = m.publicKey ? 1 : 0

    c.uint.encode(state, flags)

    if (m.publicKey) c.string.encode(state, m.publicKey)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      publicKey: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-channel-response.channel
const encoding15_0 = c.frame(encoding13)

// @peartube/get-channel-response
const encoding15 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.channel) encoding15_0.preencode(state, m.channel)
  },
  encode(state, m) {
    const flags = m.channel ? 1 : 0

    c.uint.encode(state, flags)

    if (m.channel) encoding15_0.encode(state, m.channel)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channel: (flags & 1) !== 0 ? encoding15_0.decode(state) : null
    }
  }
}

// @peartube/update-channel-request
const encoding16 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.avatar) c.string.preencode(state, m.avatar)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.avatar ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.avatar) c.string.encode(state, m.avatar)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/update-channel-response.channel
const encoding17_0 = encoding15_0

// @peartube/update-channel-response
const encoding17 = {
  preencode(state, m) {
    encoding17_0.preencode(state, m.channel)
  },
  encode(state, m) {
    encoding17_0.encode(state, m.channel)
  },
  decode(state) {
    const r0 = encoding17_0.decode(state)

    return {
      channel: r0
    }
  }
}

// @peartube/video
const encoding18 = {
  preencode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.path ? 2 : 0) |
      (m.duration ? 4 : 0) |
      (m.thumbnail ? 8 : 0) |
      (m.channelKey ? 16 : 0) |
      (m.channelName ? 32 : 0) |
      (m.createdAt ? 64 : 0) |
      (m.views ? 128 : 0) |
      (m.category ? 256 : 0)

    c.string.preencode(state, m.id)
    c.string.preencode(state, m.title)
    c.uint.preencode(state, flags)

    if (m.description) c.string.preencode(state, m.description)
    if (m.path) c.string.preencode(state, m.path)
    if (m.duration) c.uint.preencode(state, m.duration)
    if (m.thumbnail) c.string.preencode(state, m.thumbnail)
    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
    if (m.views) c.uint.preencode(state, m.views)
    if (m.category) c.string.preencode(state, m.category)
  },
  encode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.path ? 2 : 0) |
      (m.duration ? 4 : 0) |
      (m.thumbnail ? 8 : 0) |
      (m.channelKey ? 16 : 0) |
      (m.channelName ? 32 : 0) |
      (m.createdAt ? 64 : 0) |
      (m.views ? 128 : 0) |
      (m.category ? 256 : 0)

    c.string.encode(state, m.id)
    c.string.encode(state, m.title)
    c.uint.encode(state, flags)

    if (m.description) c.string.encode(state, m.description)
    if (m.path) c.string.encode(state, m.path)
    if (m.duration) c.uint.encode(state, m.duration)
    if (m.thumbnail) c.string.encode(state, m.thumbnail)
    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
    if (m.views) c.uint.encode(state, m.views)
    if (m.category) c.string.encode(state, m.category)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      id: r0,
      title: r1,
      description: (flags & 1) !== 0 ? c.string.decode(state) : null,
      path: (flags & 2) !== 0 ? c.string.decode(state) : null,
      duration: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      thumbnail: (flags & 8) !== 0 ? c.string.decode(state) : null,
      channelKey: (flags & 16) !== 0 ? c.string.decode(state) : null,
      channelName: (flags & 32) !== 0 ? c.string.decode(state) : null,
      createdAt: (flags & 64) !== 0 ? c.uint.decode(state) : 0,
      views: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      category: (flags & 256) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/list-videos-request
const encoding19 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
    if (m.limit) c.uint.preencode(state, m.limit)
    if (m.offset) c.uint.preencode(state, m.offset)
  },
  encode(state, m) {
    const flags =
      (m.channelKey ? 1 : 0) |
      (m.publicBeeKey ? 2 : 0) |
      (m.limit ? 4 : 0) |
      (m.offset ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
    if (m.limit) c.uint.encode(state, m.limit)
    if (m.offset) c.uint.encode(state, m.offset)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channelKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      publicBeeKey: (flags & 2) !== 0 ? c.string.decode(state) : null,
      limit: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      offset: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/list-videos-response.videos
const encoding20_0 = c.array(c.frame(encoding18))

// @peartube/list-videos-response
const encoding20 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.videos) encoding20_0.preencode(state, m.videos)
  },
  encode(state, m) {
    const flags = m.videos ? 1 : 0

    c.uint.encode(state, flags)

    if (m.videos) encoding20_0.encode(state, m.videos)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      videos: (flags & 1) !== 0 ? encoding20_0.decode(state) : null
    }
  }
}

// @peartube/get-video-url-request
const encoding21 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 1 so always one byte

    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags = m.publicBeeKey ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      publicBeeKey: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-video-url-response
const encoding22 = {
  preencode(state, m) {
    c.string.preencode(state, m.url)
  },
  encode(state, m) {
    c.string.encode(state, m.url)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      url: r0
    }
  }
}

// @peartube/get-video-data-request
const encoding23 = encoding21

// @peartube/get-video-data-response.video
const encoding24_0 = c.frame(encoding18)

// @peartube/get-video-data-response
const encoding24 = {
  preencode(state, m) {
    encoding24_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding24_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding24_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/upload-video-request
const encoding25 = {
  preencode(state, m) {
    c.string.preencode(state, m.filePath)
    c.string.preencode(state, m.title)
    state.end++ // max flag is 4 so always one byte

    if (m.description) c.string.preencode(state, m.description)
    if (m.category) c.string.preencode(state, m.category)
  },
  encode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.category ? 2 : 0) |
      (m.skipThumbnailGeneration ? 4 : 0)

    c.string.encode(state, m.filePath)
    c.string.encode(state, m.title)
    c.uint.encode(state, flags)

    if (m.description) c.string.encode(state, m.description)
    if (m.category) c.string.encode(state, m.category)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      filePath: r0,
      title: r1,
      description: (flags & 1) !== 0 ? c.string.decode(state) : null,
      category: (flags & 2) !== 0 ? c.string.decode(state) : null,
      skipThumbnailGeneration: (flags & 4) !== 0
    }
  }
}

// @peartube/upload-video-response.video
const encoding26_0 = encoding24_0

// @peartube/upload-video-response
const encoding26 = {
  preencode(state, m) {
    encoding26_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding26_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding26_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/download-video-request
const encoding27 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.destPath)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.destPath)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      destPath: r2
    }
  }
}

// @peartube/download-video-response
const encoding28 = {
  preencode(state, m) {
    state.end++ // max flag is 16 so always one byte

    if (m.filePath) c.string.preencode(state, m.filePath)
    if (m.size) c.uint.preencode(state, m.size)
    if (m.error) c.string.preencode(state, m.error)
    if (m.data) c.string.preencode(state, m.data)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.filePath ? 2 : 0) |
      (m.size ? 4 : 0) |
      (m.error ? 8 : 0) |
      (m.data ? 16 : 0)

    c.uint.encode(state, flags)

    if (m.filePath) c.string.encode(state, m.filePath)
    if (m.size) c.uint.encode(state, m.size)
    if (m.error) c.string.encode(state, m.error)
    if (m.data) c.string.encode(state, m.data)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      filePath: (flags & 2) !== 0 ? c.string.decode(state) : null,
      size: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      error: (flags & 8) !== 0 ? c.string.decode(state) : null,
      data: (flags & 16) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/delete-video-request
const encoding29 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
  },
  encode(state, m) {
    c.string.encode(state, m.videoId)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      videoId: r0
    }
  }
}

// @peartube/delete-video-response
const encoding30 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.error ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      error: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/subscription
const encoding31 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 4 so always one byte

    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.subscribedAt) c.uint.preencode(state, m.subscribedAt)
  },
  encode(state, m) {
    const flags =
      (m.channelName ? 1 : 0) |
      (m.avatar ? 2 : 0) |
      (m.subscribedAt ? 4 : 0)

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.subscribedAt) c.uint.encode(state, m.subscribedAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      channelName: (flags & 1) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 2) !== 0 ? c.string.decode(state) : null,
      subscribedAt: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/subscribe-channel-request
const encoding32 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      channelKey: r0
    }
  }
}

// @peartube/subscribe-channel-response
const encoding33 = encoding10

// @peartube/unsubscribe-channel-request
const encoding34 = encoding32

// @peartube/unsubscribe-channel-response
const encoding35 = encoding10

// @peartube/get-subscriptions-request
const encoding36 = encoding0

// @peartube/get-subscriptions-response.subscriptions
const encoding37_0 = c.array(c.frame(encoding31))

// @peartube/get-subscriptions-response
const encoding37 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.subscriptions) encoding37_0.preencode(state, m.subscriptions)
  },
  encode(state, m) {
    const flags = m.subscriptions ? 1 : 0

    c.uint.encode(state, flags)

    if (m.subscriptions) encoding37_0.encode(state, m.subscriptions)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      subscriptions: (flags & 1) !== 0 ? encoding37_0.decode(state) : null
    }
  }
}

// @peartube/join-channel-request
const encoding38 = encoding32

// @peartube/join-channel-response
const encoding39 = encoding10

// @peartube/feed-entry
const encoding40 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 16 so always one byte

    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
    if (m.peerCount) c.uint.preencode(state, m.peerCount)
    if (m.lastSeen) c.uint.preencode(state, m.lastSeen)
  },
  encode(state, m) {
    const flags =
      (m.publicBeeKey ? 1 : 0) |
      (m.channelName ? 2 : 0) |
      (m.videoCount ? 4 : 0) |
      (m.peerCount ? 8 : 0) |
      (m.lastSeen ? 16 : 0)

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
    if (m.peerCount) c.uint.encode(state, m.peerCount)
    if (m.lastSeen) c.uint.encode(state, m.lastSeen)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      publicBeeKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      channelName: (flags & 2) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      peerCount: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      lastSeen: (flags & 16) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-public-feed-request
const encoding41 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.limit) c.uint.preencode(state, m.limit)
  },
  encode(state, m) {
    const flags = m.limit ? 1 : 0

    c.uint.encode(state, flags)

    if (m.limit) c.uint.encode(state, m.limit)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      limit: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-public-feed-response.entries
const encoding42_0 = c.array(c.frame(encoding40))

// @peartube/get-public-feed-response
const encoding42 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.entries) encoding42_0.preencode(state, m.entries)
  },
  encode(state, m) {
    const flags = m.entries ? 1 : 0

    c.uint.encode(state, flags)

    if (m.entries) encoding42_0.encode(state, m.entries)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      entries: (flags & 1) !== 0 ? encoding42_0.decode(state) : null
    }
  }
}

// @peartube/refresh-feed-request
const encoding43 = encoding0

// @peartube/refresh-feed-response
const encoding44 = encoding10

// @peartube/submit-to-feed-request
const encoding45 = encoding0

// @peartube/submit-to-feed-response
const encoding46 = encoding10

// @peartube/unpublish-from-feed-request
const encoding47 = encoding0

// @peartube/unpublish-from-feed-response
const encoding48 = encoding10

// @peartube/is-channel-published-request
const encoding49 = encoding0

// @peartube/is-channel-published-response
const encoding50 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = m.published ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      published: (flags & 1) !== 0
    }
  }
}

// @peartube/hide-channel-request
const encoding51 = encoding32

// @peartube/hide-channel-response
const encoding52 = encoding10

// @peartube/get-channel-meta-request
const encoding53 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 1 so always one byte

    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags = m.publicBeeKey ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      publicBeeKey: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-channel-meta-response
const encoding54 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.videoCount ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-swarm-status-request
const encoding55 = encoding0

// @peartube/get-swarm-status-response
const encoding56 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.peerCount) c.uint.preencode(state, m.peerCount)
  },
  encode(state, m) {
    const flags =
      (m.connected ? 1 : 0) |
      (m.peerCount ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.peerCount) c.uint.encode(state, m.peerCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      connected: (flags & 1) !== 0,
      peerCount: (flags & 2) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/prefetch-video-request
const encoding57 = encoding21

// @peartube/prefetch-video-response
const encoding58 = encoding10

// @peartube/video-stats
const encoding59 = {
  preencode(state, m) {
    const flags =
      (m.videoId ? 1 : 0) |
      (m.channelKey ? 2 : 0) |
      (m.status ? 4 : 0) |
      (m.progress ? 8 : 0) |
      (m.totalBlocks ? 16 : 0) |
      (m.downloadedBlocks ? 32 : 0) |
      (m.totalBytes ? 64 : 0) |
      (m.downloadedBytes ? 128 : 0) |
      (m.peerCount ? 256 : 0) |
      (m.speedMBps ? 512 : 0) |
      (m.uploadSpeedMBps ? 1024 : 0) |
      (m.elapsed ? 2048 : 0) |
      (m.isComplete ? 4096 : 0)

    c.uint.preencode(state, flags)

    if (m.videoId) c.string.preencode(state, m.videoId)
    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.status) c.string.preencode(state, m.status)
    if (m.progress) c.uint.preencode(state, m.progress)
    if (m.totalBlocks) c.uint.preencode(state, m.totalBlocks)
    if (m.downloadedBlocks) c.uint.preencode(state, m.downloadedBlocks)
    if (m.totalBytes) c.uint.preencode(state, m.totalBytes)
    if (m.downloadedBytes) c.uint.preencode(state, m.downloadedBytes)
    if (m.peerCount) c.uint.preencode(state, m.peerCount)
    if (m.speedMBps) c.string.preencode(state, m.speedMBps)
    if (m.uploadSpeedMBps) c.string.preencode(state, m.uploadSpeedMBps)
    if (m.elapsed) c.uint.preencode(state, m.elapsed)
  },
  encode(state, m) {
    const flags =
      (m.videoId ? 1 : 0) |
      (m.channelKey ? 2 : 0) |
      (m.status ? 4 : 0) |
      (m.progress ? 8 : 0) |
      (m.totalBlocks ? 16 : 0) |
      (m.downloadedBlocks ? 32 : 0) |
      (m.totalBytes ? 64 : 0) |
      (m.downloadedBytes ? 128 : 0) |
      (m.peerCount ? 256 : 0) |
      (m.speedMBps ? 512 : 0) |
      (m.uploadSpeedMBps ? 1024 : 0) |
      (m.elapsed ? 2048 : 0) |
      (m.isComplete ? 4096 : 0)

    c.uint.encode(state, flags)

    if (m.videoId) c.string.encode(state, m.videoId)
    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.status) c.string.encode(state, m.status)
    if (m.progress) c.uint.encode(state, m.progress)
    if (m.totalBlocks) c.uint.encode(state, m.totalBlocks)
    if (m.downloadedBlocks) c.uint.encode(state, m.downloadedBlocks)
    if (m.totalBytes) c.uint.encode(state, m.totalBytes)
    if (m.downloadedBytes) c.uint.encode(state, m.downloadedBytes)
    if (m.peerCount) c.uint.encode(state, m.peerCount)
    if (m.speedMBps) c.string.encode(state, m.speedMBps)
    if (m.uploadSpeedMBps) c.string.encode(state, m.uploadSpeedMBps)
    if (m.elapsed) c.uint.encode(state, m.elapsed)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      videoId: (flags & 1) !== 0 ? c.string.decode(state) : null,
      channelKey: (flags & 2) !== 0 ? c.string.decode(state) : null,
      status: (flags & 4) !== 0 ? c.string.decode(state) : null,
      progress: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      totalBlocks: (flags & 16) !== 0 ? c.uint.decode(state) : 0,
      downloadedBlocks: (flags & 32) !== 0 ? c.uint.decode(state) : 0,
      totalBytes: (flags & 64) !== 0 ? c.uint.decode(state) : 0,
      downloadedBytes: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      peerCount: (flags & 256) !== 0 ? c.uint.decode(state) : 0,
      speedMBps: (flags & 512) !== 0 ? c.string.decode(state) : null,
      uploadSpeedMBps: (flags & 1024) !== 0 ? c.string.decode(state) : null,
      elapsed: (flags & 2048) !== 0 ? c.uint.decode(state) : 0,
      isComplete: (flags & 4096) !== 0
    }
  }
}

// @peartube/get-video-stats-request
const encoding60 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      channelKey: r0,
      videoId: r1
    }
  }
}

// @peartube/get-video-stats-response.stats
const encoding61_0 = c.frame(encoding59)

// @peartube/get-video-stats-response
const encoding61 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.stats) encoding61_0.preencode(state, m.stats)
  },
  encode(state, m) {
    const flags = m.stats ? 1 : 0

    c.uint.encode(state, flags)

    if (m.stats) encoding61_0.encode(state, m.stats)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      stats: (flags & 1) !== 0 ? encoding61_0.decode(state) : null
    }
  }
}

// @peartube/seeding-config
const encoding62 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.maxStorage) c.uint.preencode(state, m.maxStorage)
    if (m.maxBandwidth) c.uint.preencode(state, m.maxBandwidth)
  },
  encode(state, m) {
    const flags =
      (m.enabled ? 1 : 0) |
      (m.maxStorage ? 2 : 0) |
      (m.maxBandwidth ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.maxStorage) c.uint.encode(state, m.maxStorage)
    if (m.maxBandwidth) c.uint.encode(state, m.maxBandwidth)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      enabled: (flags & 1) !== 0,
      maxStorage: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      maxBandwidth: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/seeding-status
const encoding63 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.usedStorage) c.uint.preencode(state, m.usedStorage)
    if (m.maxStorage) c.uint.preencode(state, m.maxStorage)
    if (m.seedingCount) c.uint.preencode(state, m.seedingCount)
  },
  encode(state, m) {
    const flags =
      (m.enabled ? 1 : 0) |
      (m.usedStorage ? 2 : 0) |
      (m.maxStorage ? 4 : 0) |
      (m.seedingCount ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.usedStorage) c.uint.encode(state, m.usedStorage)
    if (m.maxStorage) c.uint.encode(state, m.maxStorage)
    if (m.seedingCount) c.uint.encode(state, m.seedingCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      enabled: (flags & 1) !== 0,
      usedStorage: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      maxStorage: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      seedingCount: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-seeding-status-request
const encoding64 = encoding0

// @peartube/get-seeding-status-response.status
const encoding65_0 = c.frame(encoding63)

// @peartube/get-seeding-status-response
const encoding65 = {
  preencode(state, m) {
    encoding65_0.preencode(state, m.status)
  },
  encode(state, m) {
    encoding65_0.encode(state, m.status)
  },
  decode(state) {
    const r0 = encoding65_0.decode(state)

    return {
      status: r0
    }
  }
}

// @peartube/set-seeding-config-request.config
const encoding66_0 = c.frame(encoding62)

// @peartube/set-seeding-config-request
const encoding66 = {
  preencode(state, m) {
    encoding66_0.preencode(state, m.config)
  },
  encode(state, m) {
    encoding66_0.encode(state, m.config)
  },
  decode(state) {
    const r0 = encoding66_0.decode(state)

    return {
      config: r0
    }
  }
}

// @peartube/set-seeding-config-response
const encoding67 = encoding10

// @peartube/pin-channel-request
const encoding68 = encoding32

// @peartube/pin-channel-response
const encoding69 = encoding10

// @peartube/unpin-channel-request
const encoding70 = encoding32

// @peartube/unpin-channel-response
const encoding71 = encoding10

// @peartube/get-pinned-channels-request
const encoding72 = encoding0

// @peartube/get-pinned-channels-response.channels
const encoding73_0 = c.array(c.string)

// @peartube/get-pinned-channels-response
const encoding73 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.channels) encoding73_0.preencode(state, m.channels)
  },
  encode(state, m) {
    const flags = m.channels ? 1 : 0

    c.uint.encode(state, flags)

    if (m.channels) encoding73_0.encode(state, m.channels)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channels: (flags & 1) !== 0 ? encoding73_0.decode(state) : null
    }
  }
}

// @peartube/get-storage-stats-request
const encoding74 = encoding0

// @peartube/get-storage-stats-response
const encoding75 = {
  preencode(state, m) {
    c.uint.preencode(state, m.usedBytes)
    c.uint.preencode(state, m.maxBytes)
    c.string.preencode(state, m.usedGB)
    c.uint.preencode(state, m.maxGB)
    c.uint.preencode(state, m.seedCount)
    c.uint.preencode(state, m.pinnedCount)
  },
  encode(state, m) {
    c.uint.encode(state, m.usedBytes)
    c.uint.encode(state, m.maxBytes)
    c.string.encode(state, m.usedGB)
    c.uint.encode(state, m.maxGB)
    c.uint.encode(state, m.seedCount)
    c.uint.encode(state, m.pinnedCount)
  },
  decode(state) {
    const r0 = c.uint.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.string.decode(state)
    const r3 = c.uint.decode(state)
    const r4 = c.uint.decode(state)
    const r5 = c.uint.decode(state)

    return {
      usedBytes: r0,
      maxBytes: r1,
      usedGB: r2,
      maxGB: r3,
      seedCount: r4,
      pinnedCount: r5
    }
  }
}

// @peartube/set-storage-limit-request
const encoding76 = {
  preencode(state, m) {
    c.uint.preencode(state, m.maxGB)
  },
  encode(state, m) {
    c.uint.encode(state, m.maxGB)
  },
  decode(state) {
    const r0 = c.uint.decode(state)

    return {
      maxGB: r0
    }
  }
}

// @peartube/set-storage-limit-response
const encoding77 = encoding10

// @peartube/clear-cache-request
const encoding78 = encoding0

// @peartube/clear-cache-response
const encoding79 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.clearedBytes) c.uint.preencode(state, m.clearedBytes)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.clearedBytes ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.clearedBytes) c.uint.encode(state, m.clearedBytes)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      clearedBytes: (flags & 2) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-video-thumbnail-request
const encoding80 = encoding60

// @peartube/get-video-thumbnail-response
const encoding81 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.url) c.string.preencode(state, m.url)
    if (m.dataUrl) c.string.preencode(state, m.dataUrl)
  },
  encode(state, m) {
    const flags =
      (m.url ? 1 : 0) |
      (m.dataUrl ? 2 : 0) |
      (m.exists ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.url) c.string.encode(state, m.url)
    if (m.dataUrl) c.string.encode(state, m.dataUrl)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      url: (flags & 1) !== 0 ? c.string.decode(state) : null,
      dataUrl: (flags & 2) !== 0 ? c.string.decode(state) : null,
      exists: (flags & 4) !== 0
    }
  }
}

// @peartube/get-video-metadata-request
const encoding82 = encoding60

// @peartube/get-video-metadata-response.video
const encoding83_0 = encoding24_0

// @peartube/get-video-metadata-response
const encoding83 = {
  preencode(state, m) {
    encoding83_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding83_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding83_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/set-video-thumbnail-request
const encoding84 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.imageData)
    state.end++ // max flag is 1 so always one byte

    if (m.mimeType) c.string.preencode(state, m.mimeType)
  },
  encode(state, m) {
    const flags = m.mimeType ? 1 : 0

    c.string.encode(state, m.videoId)
    c.string.encode(state, m.imageData)
    c.uint.encode(state, flags)

    if (m.mimeType) c.string.encode(state, m.mimeType)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      imageData: r1,
      mimeType: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/set-video-thumbnail-from-file-request
const encoding85 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.filePath)
  },
  encode(state, m) {
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.filePath)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      videoId: r0,
      filePath: r1
    }
  }
}

// @peartube/set-video-thumbnail-from-file-response
const encoding86 = encoding10

// @peartube/set-video-thumbnail-response
const encoding87 = encoding10

// @peartube/status
const encoding88 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.blobServerPort) c.uint.preencode(state, m.blobServerPort)
  },
  encode(state, m) {
    const flags =
      (m.ready ? 1 : 0) |
      (m.hasIdentity ? 2 : 0) |
      (m.blobServerPort ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.blobServerPort) c.uint.encode(state, m.blobServerPort)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      ready: (flags & 1) !== 0,
      hasIdentity: (flags & 2) !== 0,
      blobServerPort: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-status-request
const encoding89 = encoding0

// @peartube/get-status-response.status
const encoding90_0 = c.frame(encoding88)

// @peartube/get-status-response
const encoding90 = {
  preencode(state, m) {
    encoding90_0.preencode(state, m.status)
  },
  encode(state, m) {
    encoding90_0.encode(state, m.status)
  },
  decode(state) {
    const r0 = encoding90_0.decode(state)

    return {
      status: r0
    }
  }
}

// @peartube/pick-video-file-request
const encoding91 = encoding0

// @peartube/pick-video-file-response
const encoding92 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.filePath) c.string.preencode(state, m.filePath)
    if (m.name) c.string.preencode(state, m.name)
    if (m.size) c.uint.preencode(state, m.size)
  },
  encode(state, m) {
    const flags =
      (m.filePath ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.size ? 4 : 0) |
      (m.cancelled ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.filePath) c.string.encode(state, m.filePath)
    if (m.name) c.string.encode(state, m.name)
    if (m.size) c.uint.encode(state, m.size)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      filePath: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      size: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      cancelled: (flags & 8) !== 0
    }
  }
}

// @peartube/pick-image-file-request
const encoding93 = encoding0

// @peartube/pick-image-file-response
const encoding94 = {
  preencode(state, m) {
    state.end++ // max flag is 16 so always one byte

    if (m.filePath) c.string.preencode(state, m.filePath)
    if (m.name) c.string.preencode(state, m.name)
    if (m.size) c.uint.preencode(state, m.size)
    if (m.dataUrl) c.string.preencode(state, m.dataUrl)
  },
  encode(state, m) {
    const flags =
      (m.filePath ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.size ? 4 : 0) |
      (m.dataUrl ? 8 : 0) |
      (m.cancelled ? 16 : 0)

    c.uint.encode(state, flags)

    if (m.filePath) c.string.encode(state, m.filePath)
    if (m.name) c.string.encode(state, m.name)
    if (m.size) c.uint.encode(state, m.size)
    if (m.dataUrl) c.string.encode(state, m.dataUrl)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      filePath: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      size: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      dataUrl: (flags & 8) !== 0 ? c.string.decode(state) : null,
      cancelled: (flags & 16) !== 0
    }
  }
}

// @peartube/get-blob-server-port-request
const encoding95 = encoding0

// @peartube/get-blob-server-port-response
const encoding96 = {
  preencode(state, m) {
    c.uint.preencode(state, m.port)
  },
  encode(state, m) {
    c.uint.encode(state, m.port)
  },
  decode(state) {
    const r0 = c.uint.decode(state)

    return {
      port: r0
    }
  }
}

// @peartube/device
const encoding97 = {
  preencode(state, m) {
    c.string.preencode(state, m.keyHex)
    state.end++ // max flag is 8 so always one byte

    if (m.role) c.string.preencode(state, m.role)
    if (m.deviceName) c.string.preencode(state, m.deviceName)
    if (m.addedAt) c.uint.preencode(state, m.addedAt)
    if (m.blobDriveKey) c.string.preencode(state, m.blobDriveKey)
  },
  encode(state, m) {
    const flags =
      (m.role ? 1 : 0) |
      (m.deviceName ? 2 : 0) |
      (m.addedAt ? 4 : 0) |
      (m.blobDriveKey ? 8 : 0)

    c.string.encode(state, m.keyHex)
    c.uint.encode(state, flags)

    if (m.role) c.string.encode(state, m.role)
    if (m.deviceName) c.string.encode(state, m.deviceName)
    if (m.addedAt) c.uint.encode(state, m.addedAt)
    if (m.blobDriveKey) c.string.encode(state, m.blobDriveKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      keyHex: r0,
      role: (flags & 1) !== 0 ? c.string.decode(state) : null,
      deviceName: (flags & 2) !== 0 ? c.string.decode(state) : null,
      addedAt: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      blobDriveKey: (flags & 8) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/create-device-invite-request
const encoding98 = encoding32

// @peartube/create-device-invite-response
const encoding99 = {
  preencode(state, m) {
    c.string.preencode(state, m.inviteCode)
  },
  encode(state, m) {
    c.string.encode(state, m.inviteCode)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      inviteCode: r0
    }
  }
}

// @peartube/pair-device-request
const encoding100 = {
  preencode(state, m) {
    c.string.preencode(state, m.inviteCode)
    state.end++ // max flag is 1 so always one byte

    if (m.deviceName) c.string.preencode(state, m.deviceName)
  },
  encode(state, m) {
    const flags = m.deviceName ? 1 : 0

    c.string.encode(state, m.inviteCode)
    c.uint.encode(state, flags)

    if (m.deviceName) c.string.encode(state, m.deviceName)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      inviteCode: r0,
      deviceName: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/pair-device-response
const encoding101 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte
    c.string.preencode(state, m.channelKey)

    if (m.syncState) c.string.preencode(state, m.syncState)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.syncState ? 2 : 0) |
      (m.videoCount ? 4 : 0)

    c.uint.encode(state, flags)
    c.string.encode(state, m.channelKey)

    if (m.syncState) c.string.encode(state, m.syncState)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      channelKey: c.string.decode(state),
      syncState: (flags & 2) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/retry-sync-channel-request
const encoding102 = encoding32

// @peartube/retry-sync-channel-response
const encoding103 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.state) c.string.preencode(state, m.state)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.state ? 2 : 0) |
      (m.videoCount ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.state) c.string.encode(state, m.state)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      state: (flags & 2) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/list-devices-request
const encoding104 = encoding32

// @peartube/list-devices-response.devices
const encoding105_0 = c.array(c.frame(encoding97))

// @peartube/list-devices-response
const encoding105 = {
  preencode(state, m) {
    encoding105_0.preencode(state, m.devices)
  },
  encode(state, m) {
    encoding105_0.encode(state, m.devices)
  },
  decode(state) {
    const r0 = encoding105_0.decode(state)

    return {
      devices: r0
    }
  }
}

// @peartube/event-ready
const encoding106 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.blobServerPort) c.uint.preencode(state, m.blobServerPort)
  },
  encode(state, m) {
    const flags = m.blobServerPort ? 1 : 0

    c.uint.encode(state, flags)

    if (m.blobServerPort) c.uint.encode(state, m.blobServerPort)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      blobServerPort: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-error
const encoding107 = encoding1

// @peartube/event-upload-progress
const encoding108 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.uint.preencode(state, m.progress)
    state.end++ // max flag is 8 so always one byte

    if (m.bytesUploaded) c.uint.preencode(state, m.bytesUploaded)
    if (m.totalBytes) c.uint.preencode(state, m.totalBytes)
    if (m.speed) c.uint.preencode(state, m.speed)
    if (m.eta) c.uint.preencode(state, m.eta)
  },
  encode(state, m) {
    const flags =
      (m.bytesUploaded ? 1 : 0) |
      (m.totalBytes ? 2 : 0) |
      (m.speed ? 4 : 0) |
      (m.eta ? 8 : 0)

    c.string.encode(state, m.videoId)
    c.uint.encode(state, m.progress)
    c.uint.encode(state, flags)

    if (m.bytesUploaded) c.uint.encode(state, m.bytesUploaded)
    if (m.totalBytes) c.uint.encode(state, m.totalBytes)
    if (m.speed) c.uint.encode(state, m.speed)
    if (m.eta) c.uint.encode(state, m.eta)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      progress: r1,
      bytesUploaded: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      totalBytes: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      speed: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      eta: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-download-progress
const encoding109 = {
  preencode(state, m) {
    c.string.preencode(state, m.id)
    c.uint.preencode(state, m.progress)
    state.end++ // max flag is 2 so always one byte

    if (m.bytesDownloaded) c.uint.preencode(state, m.bytesDownloaded)
    if (m.totalBytes) c.uint.preencode(state, m.totalBytes)
  },
  encode(state, m) {
    const flags =
      (m.bytesDownloaded ? 1 : 0) |
      (m.totalBytes ? 2 : 0)

    c.string.encode(state, m.id)
    c.uint.encode(state, m.progress)
    c.uint.encode(state, flags)

    if (m.bytesDownloaded) c.uint.encode(state, m.bytesDownloaded)
    if (m.totalBytes) c.uint.encode(state, m.totalBytes)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      id: r0,
      progress: r1,
      bytesDownloaded: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      totalBytes: (flags & 2) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-feed-update
const encoding110 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.action)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.action)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      channelKey: r0,
      action: r1
    }
  }
}

// @peartube/event-log
const encoding111 = {
  preencode(state, m) {
    c.string.preencode(state, m.level)
    c.string.preencode(state, m.message)
    state.end++ // max flag is 1 so always one byte

    if (m.timestamp) c.uint.preencode(state, m.timestamp)
  },
  encode(state, m) {
    const flags = m.timestamp ? 1 : 0

    c.string.encode(state, m.level)
    c.string.encode(state, m.message)
    c.uint.encode(state, flags)

    if (m.timestamp) c.uint.encode(state, m.timestamp)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      level: r0,
      message: r1,
      timestamp: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-video-stats.stats
const encoding112_0 = encoding61_0

// @peartube/event-video-stats
const encoding112 = {
  preencode(state, m) {
    encoding112_0.preencode(state, m.stats)
  },
  encode(state, m) {
    encoding112_0.encode(state, m.stats)
  },
  decode(state) {
    const r0 = encoding112_0.decode(state)

    return {
      stats: r0
    }
  }
}

// @peartube/channel-op-base
const encoding113 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
  },
  encode(state, m) {
    const flags = m.schemaVersion ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-update-channel
const encoding114 = {
  preencode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.key ? 2 : 0) |
      (m.name ? 4 : 0) |
      (m.description ? 8 : 0) |
      (m.avatar ? 16 : 0) |
      (m.updatedAt ? 32 : 0) |
      (m.updatedBy ? 64 : 0) |
      (m.createdAt ? 128 : 0) |
      (m.createdBy ? 256 : 0)

    c.string.preencode(state, m.type)
    c.uint.preencode(state, flags)

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    if (m.key) c.string.preencode(state, m.key)
    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.updatedAt) c.uint.preencode(state, m.updatedAt)
    if (m.updatedBy) c.string.preencode(state, m.updatedBy)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
    if (m.createdBy) c.string.preencode(state, m.createdBy)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.key ? 2 : 0) |
      (m.name ? 4 : 0) |
      (m.description ? 8 : 0) |
      (m.avatar ? 16 : 0) |
      (m.updatedAt ? 32 : 0) |
      (m.updatedBy ? 64 : 0) |
      (m.createdAt ? 128 : 0) |
      (m.createdBy ? 256 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    if (m.key) c.string.encode(state, m.key)
    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.updatedAt) c.uint.encode(state, m.updatedAt)
    if (m.updatedBy) c.string.encode(state, m.updatedBy)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
    if (m.createdBy) c.string.encode(state, m.createdBy)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      key: (flags & 2) !== 0 ? c.string.decode(state) : null,
      name: (flags & 4) !== 0 ? c.string.decode(state) : null,
      description: (flags & 8) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 16) !== 0 ? c.string.decode(state) : null,
      updatedAt: (flags & 32) !== 0 ? c.uint.decode(state) : 0,
      updatedBy: (flags & 64) !== 0 ? c.string.decode(state) : null,
      createdAt: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      createdBy: (flags & 256) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-add-video
const encoding115 = {
  preencode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.path ? 4 : 0) |
      (m.duration ? 8 : 0) |
      (m.thumbnail ? 16 : 0) |
      (m.blobDriveKey ? 32 : 0) |
      (m.mimeType ? 64 : 0) |
      (m.size ? 128 : 0) |
      (m.uploadedAt ? 256 : 0) |
      (m.uploadedBy ? 512 : 0) |
      (m.category ? 1024 : 0) |
      (m.views ? 2048 : 0)

    c.string.preencode(state, m.type)
    c.uint.preencode(state, flags)

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.id)
    c.string.preencode(state, m.title)
    if (m.description) c.string.preencode(state, m.description)
    if (m.path) c.string.preencode(state, m.path)
    if (m.duration) c.uint.preencode(state, m.duration)
    if (m.thumbnail) c.string.preencode(state, m.thumbnail)
    if (m.blobDriveKey) c.string.preencode(state, m.blobDriveKey)
    if (m.mimeType) c.string.preencode(state, m.mimeType)
    if (m.size) c.uint.preencode(state, m.size)
    if (m.uploadedAt) c.uint.preencode(state, m.uploadedAt)
    if (m.uploadedBy) c.string.preencode(state, m.uploadedBy)
    if (m.category) c.string.preencode(state, m.category)
    if (m.views) c.uint.preencode(state, m.views)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.path ? 4 : 0) |
      (m.duration ? 8 : 0) |
      (m.thumbnail ? 16 : 0) |
      (m.blobDriveKey ? 32 : 0) |
      (m.mimeType ? 64 : 0) |
      (m.size ? 128 : 0) |
      (m.uploadedAt ? 256 : 0) |
      (m.uploadedBy ? 512 : 0) |
      (m.category ? 1024 : 0) |
      (m.views ? 2048 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.id)
    c.string.encode(state, m.title)
    if (m.description) c.string.encode(state, m.description)
    if (m.path) c.string.encode(state, m.path)
    if (m.duration) c.uint.encode(state, m.duration)
    if (m.thumbnail) c.string.encode(state, m.thumbnail)
    if (m.blobDriveKey) c.string.encode(state, m.blobDriveKey)
    if (m.mimeType) c.string.encode(state, m.mimeType)
    if (m.size) c.uint.encode(state, m.size)
    if (m.uploadedAt) c.uint.encode(state, m.uploadedAt)
    if (m.uploadedBy) c.string.encode(state, m.uploadedBy)
    if (m.category) c.string.encode(state, m.category)
    if (m.views) c.uint.encode(state, m.views)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      id: c.string.decode(state),
      title: c.string.decode(state),
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      path: (flags & 4) !== 0 ? c.string.decode(state) : null,
      duration: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      thumbnail: (flags & 16) !== 0 ? c.string.decode(state) : null,
      blobDriveKey: (flags & 32) !== 0 ? c.string.decode(state) : null,
      mimeType: (flags & 64) !== 0 ? c.string.decode(state) : null,
      size: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      uploadedAt: (flags & 256) !== 0 ? c.uint.decode(state) : 0,
      uploadedBy: (flags & 512) !== 0 ? c.string.decode(state) : null,
      category: (flags & 1024) !== 0 ? c.string.decode(state) : null,
      views: (flags & 2048) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-update-video
const encoding116 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 64 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.id)
    if (m.title) c.string.preencode(state, m.title)
    if (m.description) c.string.preencode(state, m.description)
    if (m.thumbnail) c.string.preencode(state, m.thumbnail)
    if (m.category) c.string.preencode(state, m.category)
    if (m.updatedAt) c.uint.preencode(state, m.updatedAt)
    if (m.updatedBy) c.string.preencode(state, m.updatedBy)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.title ? 2 : 0) |
      (m.description ? 4 : 0) |
      (m.thumbnail ? 8 : 0) |
      (m.category ? 16 : 0) |
      (m.updatedAt ? 32 : 0) |
      (m.updatedBy ? 64 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.id)
    if (m.title) c.string.encode(state, m.title)
    if (m.description) c.string.encode(state, m.description)
    if (m.thumbnail) c.string.encode(state, m.thumbnail)
    if (m.category) c.string.encode(state, m.category)
    if (m.updatedAt) c.uint.encode(state, m.updatedAt)
    if (m.updatedBy) c.string.encode(state, m.updatedBy)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      id: c.string.decode(state),
      title: (flags & 2) !== 0 ? c.string.decode(state) : null,
      description: (flags & 4) !== 0 ? c.string.decode(state) : null,
      thumbnail: (flags & 8) !== 0 ? c.string.decode(state) : null,
      category: (flags & 16) !== 0 ? c.string.decode(state) : null,
      updatedAt: (flags & 32) !== 0 ? c.uint.decode(state) : 0,
      updatedBy: (flags & 64) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-delete-video
const encoding117 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.id)
  },
  encode(state, m) {
    const flags = m.schemaVersion ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.id)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      id: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-add-writer
const encoding118 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 16 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.keyHex)
    if (m.role) c.string.preencode(state, m.role)
    if (m.deviceName) c.string.preencode(state, m.deviceName)
    if (m.addedAt) c.uint.preencode(state, m.addedAt)
    if (m.blobDriveKey) c.string.preencode(state, m.blobDriveKey)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.role ? 2 : 0) |
      (m.deviceName ? 4 : 0) |
      (m.addedAt ? 8 : 0) |
      (m.blobDriveKey ? 16 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.keyHex)
    if (m.role) c.string.encode(state, m.role)
    if (m.deviceName) c.string.encode(state, m.deviceName)
    if (m.addedAt) c.uint.encode(state, m.addedAt)
    if (m.blobDriveKey) c.string.encode(state, m.blobDriveKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      keyHex: c.string.decode(state),
      role: (flags & 2) !== 0 ? c.string.decode(state) : null,
      deviceName: (flags & 4) !== 0 ? c.string.decode(state) : null,
      addedAt: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      blobDriveKey: (flags & 16) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-upsert-writer
const encoding119 = encoding118

// @peartube/channel-op-remove-writer
const encoding120 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 2 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.keyHex)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.ban ? 2 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.keyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      keyHex: c.string.decode(state),
      ban: (flags & 2) !== 0
    }
  }
}

// @peartube/channel-op-add-invite
const encoding121 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 8 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.idHex)
    c.string.preencode(state, m.inviteZ32)
    if (m.publicKeyHex) c.string.preencode(state, m.publicKeyHex)
    if (m.expires) c.uint.preencode(state, m.expires)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.publicKeyHex ? 2 : 0) |
      (m.expires ? 4 : 0) |
      (m.createdAt ? 8 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.idHex)
    c.string.encode(state, m.inviteZ32)
    if (m.publicKeyHex) c.string.encode(state, m.publicKeyHex)
    if (m.expires) c.uint.encode(state, m.expires)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      idHex: c.string.decode(state),
      inviteZ32: c.string.decode(state),
      publicKeyHex: (flags & 2) !== 0 ? c.string.decode(state) : null,
      expires: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      createdAt: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-delete-invite
const encoding122 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.idHex)
  },
  encode(state, m) {
    const flags = m.schemaVersion ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.idHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      idHex: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-add-comment
const encoding123 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 4 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    c.string.preencode(state, m.text)
    c.string.preencode(state, m.authorKeyHex)
    if (m.timestamp) c.uint.preencode(state, m.timestamp)
    if (m.parentId) c.string.preencode(state, m.parentId)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.timestamp ? 2 : 0) |
      (m.parentId ? 4 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.string.encode(state, m.text)
    c.string.encode(state, m.authorKeyHex)
    if (m.timestamp) c.uint.encode(state, m.timestamp)
    if (m.parentId) c.string.encode(state, m.parentId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      commentId: c.string.decode(state),
      text: c.string.decode(state),
      authorKeyHex: c.string.decode(state),
      timestamp: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      parentId: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-add-reaction
const encoding124 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 2 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.reactionType)
    c.string.preencode(state, m.authorKeyHex)
    if (m.timestamp) c.uint.preencode(state, m.timestamp)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.timestamp ? 2 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.reactionType)
    c.string.encode(state, m.authorKeyHex)
    if (m.timestamp) c.uint.encode(state, m.timestamp)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      reactionType: c.string.decode(state),
      authorKeyHex: c.string.decode(state),
      timestamp: (flags & 2) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-remove-reaction
const encoding125 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.authorKeyHex)
  },
  encode(state, m) {
    const flags = m.schemaVersion ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.authorKeyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      authorKeyHex: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-hide-comment
const encoding126 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    c.string.preencode(state, m.moderatorKeyHex)
  },
  encode(state, m) {
    const flags = m.schemaVersion ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.string.encode(state, m.moderatorKeyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      commentId: c.string.decode(state),
      moderatorKeyHex: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-remove-comment
const encoding127 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 4 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    if (m.moderatorKeyHex) c.string.preencode(state, m.moderatorKeyHex)
    if (m.authorKeyHex) c.string.preencode(state, m.authorKeyHex)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.moderatorKeyHex ? 2 : 0) |
      (m.authorKeyHex ? 4 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    if (m.moderatorKeyHex) c.string.encode(state, m.moderatorKeyHex)
    if (m.authorKeyHex) c.string.encode(state, m.authorKeyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      commentId: c.string.decode(state),
      moderatorKeyHex: (flags & 2) !== 0 ? c.string.decode(state) : null,
      authorKeyHex: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-add-vector-index
const encoding128 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 8 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    if (m.vector) c.string.preencode(state, m.vector)
    if (m.text) c.string.preencode(state, m.text)
    if (m.metadata) c.string.preencode(state, m.metadata)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.vector ? 2 : 0) |
      (m.text ? 4 : 0) |
      (m.metadata ? 8 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    if (m.vector) c.string.encode(state, m.vector)
    if (m.text) c.string.encode(state, m.text)
    if (m.metadata) c.string.encode(state, m.metadata)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      vector: (flags & 2) !== 0 ? c.string.decode(state) : null,
      text: (flags & 4) !== 0 ? c.string.decode(state) : null,
      metadata: (flags & 8) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-log-watch-event
const encoding129 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 32 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.watcherKeyHex) c.string.preencode(state, m.watcherKeyHex)
    if (m.duration) c.uint.preencode(state, m.duration)
    if (m.timestamp) c.uint.preencode(state, m.timestamp)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.channelKey ? 2 : 0) |
      (m.watcherKeyHex ? 4 : 0) |
      (m.duration ? 8 : 0) |
      (m.completed ? 16 : 0) |
      (m.timestamp ? 32 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.watcherKeyHex) c.string.encode(state, m.watcherKeyHex)
    if (m.duration) c.uint.encode(state, m.duration)
    if (m.timestamp) c.uint.encode(state, m.timestamp)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      channelKey: (flags & 2) !== 0 ? c.string.decode(state) : null,
      watcherKeyHex: (flags & 4) !== 0 ? c.string.decode(state) : null,
      duration: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      completed: (flags & 16) !== 0,
      timestamp: (flags & 32) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-migrate-schema
const encoding130 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    c.uint.preencode(state, m.schemaVersion)
    c.uint.preencode(state, m.fromVersion)
    c.uint.preencode(state, m.toVersion)
    state.end++ // max flag is 1 so always one byte

    if (m.migratedAt) c.uint.preencode(state, m.migratedAt)
  },
  encode(state, m) {
    const flags = m.migratedAt ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, m.schemaVersion)
    c.uint.encode(state, m.fromVersion)
    c.uint.encode(state, m.toVersion)
    c.uint.encode(state, flags)

    if (m.migratedAt) c.uint.encode(state, m.migratedAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.uint.decode(state)
    const r3 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: r1,
      fromVersion: r2,
      toVersion: r3,
      migratedAt: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/add-comment-request
const encoding131 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.text)
    state.end++ // max flag is 4 so always one byte

    if (m.parentId) c.string.preencode(state, m.parentId)
    if (m.authorChannelKey) c.string.preencode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags =
      (m.parentId ? 1 : 0) |
      (m.authorChannelKey ? 2 : 0) |
      (m.publicBeeKey ? 4 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.text)
    c.uint.encode(state, flags)

    if (m.parentId) c.string.encode(state, m.parentId)
    if (m.authorChannelKey) c.string.encode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      text: r2,
      parentId: (flags & 1) !== 0 ? c.string.decode(state) : null,
      authorChannelKey: (flags & 2) !== 0 ? c.string.decode(state) : null,
      publicBeeKey: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/add-comment-response
const encoding132 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.commentId) c.string.preencode(state, m.commentId)
    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.commentId ? 2 : 0) |
      (m.queued ? 4 : 0) |
      (m.error ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.commentId) c.string.encode(state, m.commentId)
    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      commentId: (flags & 2) !== 0 ? c.string.decode(state) : null,
      queued: (flags & 4) !== 0,
      error: (flags & 8) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/list-comments-request
const encoding133 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 4 so always one byte

    if (m.page) c.uint.preencode(state, m.page)
    if (m.limit) c.uint.preencode(state, m.limit)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags =
      (m.page ? 1 : 0) |
      (m.limit ? 2 : 0) |
      (m.publicBeeKey ? 4 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (m.page) c.uint.encode(state, m.page)
    if (m.limit) c.uint.encode(state, m.limit)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      page: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      limit: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      publicBeeKey: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/comment
const encoding134 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    c.string.preencode(state, m.text)
    c.string.preencode(state, m.authorKeyHex)
    state.end++ // max flag is 4 so always one byte

    if (m.timestamp) c.uint.preencode(state, m.timestamp)
    if (m.parentId) c.string.preencode(state, m.parentId)
  },
  encode(state, m) {
    const flags =
      (m.timestamp ? 1 : 0) |
      (m.parentId ? 2 : 0) |
      (m.isAdmin ? 4 : 0)

    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.string.encode(state, m.text)
    c.string.encode(state, m.authorKeyHex)
    c.uint.encode(state, flags)

    if (m.timestamp) c.uint.encode(state, m.timestamp)
    if (m.parentId) c.string.encode(state, m.parentId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const r3 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      commentId: r1,
      text: r2,
      authorKeyHex: r3,
      timestamp: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      parentId: (flags & 2) !== 0 ? c.string.decode(state) : null,
      isAdmin: (flags & 4) !== 0
    }
  }
}

// @peartube/list-comments-response.comments
const encoding135_1 = c.array(c.frame(encoding134))

// @peartube/list-comments-response
const encoding135 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte
    encoding135_1.preencode(state, m.comments)

    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.error ? 2 : 0)

    c.uint.encode(state, flags)
    encoding135_1.encode(state, m.comments)

    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      comments: encoding135_1.decode(state),
      error: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/hide-comment-request
const encoding136 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    state.end++ // max flag is 1 so always one byte

    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags = m.publicBeeKey ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.uint.encode(state, flags)

    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      commentId: r2,
      publicBeeKey: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/hide-comment-response
const encoding137 = encoding30

// @peartube/remove-comment-request
const encoding138 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    state.end++ // max flag is 2 so always one byte

    if (m.authorChannelKey) c.string.preencode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags =
      (m.authorChannelKey ? 1 : 0) |
      (m.publicBeeKey ? 2 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.uint.encode(state, flags)

    if (m.authorChannelKey) c.string.encode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      commentId: r2,
      authorChannelKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      publicBeeKey: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/remove-comment-response
const encoding139 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.queued ? 2 : 0) |
      (m.error ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      queued: (flags & 2) !== 0,
      error: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/reaction-count
const encoding140 = {
  preencode(state, m) {
    c.string.preencode(state, m.reactionType)
    c.uint.preencode(state, m.count)
  },
  encode(state, m) {
    c.string.encode(state, m.reactionType)
    c.uint.encode(state, m.count)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)

    return {
      reactionType: r0,
      count: r1
    }
  }
}

// @peartube/add-reaction-request
const encoding141 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.reactionType)
    state.end++ // max flag is 2 so always one byte

    if (m.authorChannelKey) c.string.preencode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags =
      (m.authorChannelKey ? 1 : 0) |
      (m.publicBeeKey ? 2 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.reactionType)
    c.uint.encode(state, flags)

    if (m.authorChannelKey) c.string.encode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      reactionType: r2,
      authorChannelKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      publicBeeKey: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/add-reaction-response
const encoding142 = encoding139

// @peartube/remove-reaction-request
const encoding143 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 2 so always one byte

    if (m.authorChannelKey) c.string.preencode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags =
      (m.authorChannelKey ? 1 : 0) |
      (m.publicBeeKey ? 2 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (m.authorChannelKey) c.string.encode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      authorChannelKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      publicBeeKey: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/remove-reaction-response
const encoding144 = encoding139

// @peartube/get-reactions-request
const encoding145 = encoding143

// @peartube/get-reactions-response.counts
const encoding146_1 = c.array(c.frame(encoding140))

// @peartube/get-reactions-response
const encoding146 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte
    encoding146_1.preencode(state, m.counts)

    if (m.userReaction) c.string.preencode(state, m.userReaction)
    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.userReaction ? 2 : 0) |
      (m.error ? 4 : 0)

    c.uint.encode(state, flags)
    encoding146_1.encode(state, m.counts)

    if (m.userReaction) c.string.encode(state, m.userReaction)
    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      counts: encoding146_1.decode(state),
      userReaction: (flags & 2) !== 0 ? c.string.decode(state) : null,
      error: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/cast-device
const encoding147 = {
  preencode(state, m) {
    c.string.preencode(state, m.id)
    c.string.preencode(state, m.name)
    c.string.preencode(state, m.host)
    c.uint.preencode(state, m.port)
    c.string.preencode(state, m.protocol)
  },
  encode(state, m) {
    c.string.encode(state, m.id)
    c.string.encode(state, m.name)
    c.string.encode(state, m.host)
    c.uint.encode(state, m.port)
    c.string.encode(state, m.protocol)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const r3 = c.uint.decode(state)
    const r4 = c.string.decode(state)

    return {
      id: r0,
      name: r1,
      host: r2,
      port: r3,
      protocol: r4
    }
  }
}

// @peartube/cast-available-request
const encoding148 = encoding0

// @peartube/cast-available-response
const encoding149 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = m.available ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      available: (flags & 1) !== 0
    }
  }
}

// @peartube/cast-start-discovery-request
const encoding150 = encoding0

// @peartube/cast-start-discovery-response
const encoding151 = encoding10

// @peartube/cast-stop-discovery-request
const encoding152 = encoding0

// @peartube/cast-stop-discovery-response
const encoding153 = encoding10

// @peartube/cast-get-devices-request
const encoding154 = encoding0

// @peartube/cast-get-devices-response.devices
const encoding155_0 = c.array(c.frame(encoding147))

// @peartube/cast-get-devices-response
const encoding155 = {
  preencode(state, m) {
    encoding155_0.preencode(state, m.devices)
  },
  encode(state, m) {
    encoding155_0.encode(state, m.devices)
  },
  decode(state) {
    const r0 = encoding155_0.decode(state)

    return {
      devices: r0
    }
  }
}

// @peartube/cast-add-manual-device-request
const encoding156 = {
  preencode(state, m) {
    c.string.preencode(state, m.name)
    c.string.preencode(state, m.host)
    state.end++ // max flag is 2 so always one byte

    if (m.port) c.uint.preencode(state, m.port)
    if (m.protocol) c.string.preencode(state, m.protocol)
  },
  encode(state, m) {
    const flags =
      (m.port ? 1 : 0) |
      (m.protocol ? 2 : 0)

    c.string.encode(state, m.name)
    c.string.encode(state, m.host)
    c.uint.encode(state, flags)

    if (m.port) c.uint.encode(state, m.port)
    if (m.protocol) c.string.encode(state, m.protocol)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      name: r0,
      host: r1,
      port: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      protocol: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/cast-add-manual-device-response.device
const encoding157_1 = c.frame(encoding147)

// @peartube/cast-add-manual-device-response
const encoding157 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.device) encoding157_1.preencode(state, m.device)
    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.device ? 2 : 0) |
      (m.error ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.device) encoding157_1.encode(state, m.device)
    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      device: (flags & 2) !== 0 ? encoding157_1.decode(state) : null,
      error: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/cast-connect-request
const encoding158 = {
  preencode(state, m) {
    c.string.preencode(state, m.deviceId)
  },
  encode(state, m) {
    c.string.encode(state, m.deviceId)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      deviceId: r0
    }
  }
}

// @peartube/cast-connect-response
const encoding159 = encoding30

// @peartube/cast-disconnect-request
const encoding160 = encoding0

// @peartube/cast-disconnect-response
const encoding161 = encoding30

// @peartube/cast-play-request
const encoding162 = {
  preencode(state, m) {
    c.string.preencode(state, m.url)
    c.string.preencode(state, m.contentType)
    state.end++ // max flag is 8 so always one byte

    if (m.title) c.string.preencode(state, m.title)
    if (m.thumbnail) c.string.preencode(state, m.thumbnail)
    if (m.time) c.uint.preencode(state, m.time)
    if (m.volume) c.uint.preencode(state, m.volume)
  },
  encode(state, m) {
    const flags =
      (m.title ? 1 : 0) |
      (m.thumbnail ? 2 : 0) |
      (m.time ? 4 : 0) |
      (m.volume ? 8 : 0)

    c.string.encode(state, m.url)
    c.string.encode(state, m.contentType)
    c.uint.encode(state, flags)

    if (m.title) c.string.encode(state, m.title)
    if (m.thumbnail) c.string.encode(state, m.thumbnail)
    if (m.time) c.uint.encode(state, m.time)
    if (m.volume) c.uint.encode(state, m.volume)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      url: r0,
      contentType: r1,
      title: (flags & 1) !== 0 ? c.string.decode(state) : null,
      thumbnail: (flags & 2) !== 0 ? c.string.decode(state) : null,
      time: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      volume: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/cast-play-response
const encoding163 = encoding30

// @peartube/cast-pause-request
const encoding164 = encoding0

// @peartube/cast-pause-response
const encoding165 = encoding30

// @peartube/cast-resume-request
const encoding166 = encoding0

// @peartube/cast-resume-response
const encoding167 = encoding30

// @peartube/cast-stop-request
const encoding168 = encoding0

// @peartube/cast-stop-response
const encoding169 = encoding30

// @peartube/cast-seek-request
const encoding170 = {
  preencode(state, m) {
    c.uint.preencode(state, m.time)
  },
  encode(state, m) {
    c.uint.encode(state, m.time)
  },
  decode(state) {
    const r0 = c.uint.decode(state)

    return {
      time: r0
    }
  }
}

// @peartube/cast-seek-response
const encoding171 = encoding30

// @peartube/cast-set-volume-request
const encoding172 = {
  preencode(state, m) {
    c.uint.preencode(state, m.volume)
  },
  encode(state, m) {
    c.uint.encode(state, m.volume)
  },
  decode(state) {
    const r0 = c.uint.decode(state)

    return {
      volume: r0
    }
  }
}

// @peartube/cast-set-volume-response
const encoding173 = encoding30

// @peartube/cast-get-state-request
const encoding174 = encoding0

// @peartube/cast-get-state-response
const encoding175 = {
  preencode(state, m) {
    c.string.preencode(state, m.state)
    state.end++ // max flag is 4 so always one byte

    if (m.currentTime) c.uint.preencode(state, m.currentTime)
    if (m.duration) c.uint.preencode(state, m.duration)
    if (m.volume) c.uint.preencode(state, m.volume)
  },
  encode(state, m) {
    const flags =
      (m.currentTime ? 1 : 0) |
      (m.duration ? 2 : 0) |
      (m.volume ? 4 : 0)

    c.string.encode(state, m.state)
    c.uint.encode(state, flags)

    if (m.currentTime) c.uint.encode(state, m.currentTime)
    if (m.duration) c.uint.encode(state, m.duration)
    if (m.volume) c.uint.encode(state, m.volume)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      state: r0,
      currentTime: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      duration: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      volume: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/cast-is-connected-request
const encoding176 = encoding0

// @peartube/cast-is-connected-response
const encoding177 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = m.connected ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      connected: (flags & 1) !== 0
    }
  }
}

// @peartube/event-cast-device-found.device
const encoding178_0 = encoding157_1

// @peartube/event-cast-device-found
const encoding178 = {
  preencode(state, m) {
    encoding178_0.preencode(state, m.device)
  },
  encode(state, m) {
    encoding178_0.encode(state, m.device)
  },
  decode(state) {
    const r0 = encoding178_0.decode(state)

    return {
      device: r0
    }
  }
}

// @peartube/event-cast-device-lost
const encoding179 = encoding158

// @peartube/event-cast-playback-state
const encoding180 = {
  preencode(state, m) {
    c.string.preencode(state, m.state)
  },
  encode(state, m) {
    c.string.encode(state, m.state)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      state: r0
    }
  }
}

// @peartube/event-cast-time-update
const encoding181 = {
  preencode(state, m) {
    c.uint.preencode(state, m.currentTime)
  },
  encode(state, m) {
    c.uint.encode(state, m.currentTime)
  },
  decode(state) {
    const r0 = c.uint.decode(state)

    return {
      currentTime: r0
    }
  }
}

// @peartube/search-result
const encoding182 = {
  preencode(state, m) {
    c.string.preencode(state, m.id)
    state.end++ // max flag is 2 so always one byte

    if (version >= 2 && m.score) c.string.preencode(state, m.score)
    if (version >= 2 && m.metadata) c.string.preencode(state, m.metadata)
  },
  encode(state, m) {
    const flags =
      ((version >= 2 && m.score) ? 1 : 0) |
      ((version >= 2 && m.metadata) ? 2 : 0)

    c.string.encode(state, m.id)
    c.uint.encode(state, flags)

    if (version >= 2 && m.score) c.string.encode(state, m.score)
    if (version >= 2 && m.metadata) c.string.encode(state, m.metadata)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      id: r0,
      score: (version >= 2 && (flags & 1) !== 0) ? c.string.decode(state) : null,
      metadata: (version >= 2 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/global-search-videos-request
const encoding183 = {
  preencode(state, m) {
    c.string.preencode(state, m.query)
    state.end++ // max flag is 1 so always one byte

    if (version >= 2 && m.topK) c.uint.preencode(state, m.topK)
  },
  encode(state, m) {
    const flags = (version >= 2 && m.topK) ? 1 : 0

    c.string.encode(state, m.query)
    c.uint.encode(state, flags)

    if (version >= 2 && m.topK) c.uint.encode(state, m.topK)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      query: r0,
      topK: (version >= 2 && (flags & 1) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/global-search-videos-response.results
const encoding184_0 = c.array(c.frame(encoding182))

// @peartube/global-search-videos-response
const encoding184 = {
  preencode(state, m) {
    encoding184_0.preencode(state, m.results)
  },
  encode(state, m) {
    encoding184_0.encode(state, m.results)
  },
  decode(state) {
    const r0 = encoding184_0.decode(state)

    return {
      results: r0
    }
  }
}

// @peartube/mpv-available-request
const encoding185 = encoding0

// @peartube/mpv-available-response
const encoding186 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (version >= 2 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 2 && m.available) ? 1 : 0) |
      ((version >= 2 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)

    if (version >= 2 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      available: (version >= 2 && (flags & 1) !== 0),
      error: (version >= 2 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/mpv-create-request
const encoding187 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (version >= 2 && m.width) c.uint.preencode(state, m.width)
    if (version >= 2 && m.height) c.uint.preencode(state, m.height)
  },
  encode(state, m) {
    const flags =
      ((version >= 2 && m.width) ? 1 : 0) |
      ((version >= 2 && m.height) ? 2 : 0)

    c.uint.encode(state, flags)

    if (version >= 2 && m.width) c.uint.encode(state, m.width)
    if (version >= 2 && m.height) c.uint.encode(state, m.height)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      width: (version >= 2 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      height: (version >= 2 && (flags & 2) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/mpv-create-response
const encoding188 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (version >= 2 && m.playerId) c.string.preencode(state, m.playerId)
    if (version >= 2 && m.frameServerPort) c.uint.preencode(state, m.frameServerPort)
    if (version >= 2 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 2 && m.success) ? 1 : 0) |
      ((version >= 2 && m.playerId) ? 2 : 0) |
      ((version >= 2 && m.frameServerPort) ? 4 : 0) |
      ((version >= 2 && m.error) ? 8 : 0)

    c.uint.encode(state, flags)

    if (version >= 2 && m.playerId) c.string.encode(state, m.playerId)
    if (version >= 2 && m.frameServerPort) c.uint.encode(state, m.frameServerPort)
    if (version >= 2 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 2 && (flags & 1) !== 0),
      playerId: (version >= 2 && (flags & 2) !== 0) ? c.string.decode(state) : null,
      frameServerPort: (version >= 2 && (flags & 4) !== 0) ? c.uint.decode(state) : 0,
      error: (version >= 2 && (flags & 8) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/mpv-load-file-request
const encoding189 = {
  preencode(state, m) {
    c.string.preencode(state, m.playerId)
    c.string.preencode(state, m.url)
  },
  encode(state, m) {
    c.string.encode(state, m.playerId)
    c.string.encode(state, m.url)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      playerId: r0,
      url: r1
    }
  }
}

// @peartube/mpv-load-file-response
const encoding190 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (version >= 2 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 2 && m.success) ? 1 : 0) |
      ((version >= 2 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)

    if (version >= 2 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 2 && (flags & 1) !== 0),
      error: (version >= 2 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/mpv-play-request
const encoding191 = {
  preencode(state, m) {
    c.string.preencode(state, m.playerId)
  },
  encode(state, m) {
    c.string.encode(state, m.playerId)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      playerId: r0
    }
  }
}

// @peartube/mpv-play-response
const encoding192 = encoding190

// @peartube/mpv-pause-request
const encoding193 = encoding191

// @peartube/mpv-pause-response
const encoding194 = encoding190

// @peartube/mpv-seek-request
const encoding195 = {
  preencode(state, m) {
    c.string.preencode(state, m.playerId)
    c.uint.preencode(state, m.time)
  },
  encode(state, m) {
    c.string.encode(state, m.playerId)
    c.uint.encode(state, m.time)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)

    return {
      playerId: r0,
      time: r1
    }
  }
}

// @peartube/mpv-seek-response
const encoding196 = encoding190

// @peartube/mpv-get-state-request
const encoding197 = encoding191

// @peartube/mpv-get-state-response
const encoding198 = {
  preencode(state, m) {
    state.end++ // max flag is 16 so always one byte

    if (version >= 2 && m.currentTime) c.uint.preencode(state, m.currentTime)
    if (version >= 2 && m.duration) c.uint.preencode(state, m.duration)
    if (version >= 2 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 2 && m.success) ? 1 : 0) |
      ((version >= 2 && m.currentTime) ? 2 : 0) |
      ((version >= 2 && m.duration) ? 4 : 0) |
      ((version >= 2 && m.paused) ? 8 : 0) |
      ((version >= 2 && m.error) ? 16 : 0)

    c.uint.encode(state, flags)

    if (version >= 2 && m.currentTime) c.uint.encode(state, m.currentTime)
    if (version >= 2 && m.duration) c.uint.encode(state, m.duration)
    if (version >= 2 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 2 && (flags & 1) !== 0),
      currentTime: (version >= 2 && (flags & 2) !== 0) ? c.uint.decode(state) : 0,
      duration: (version >= 2 && (flags & 4) !== 0) ? c.uint.decode(state) : 0,
      paused: (version >= 2 && (flags & 8) !== 0),
      error: (version >= 2 && (flags & 16) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/mpv-render-frame-request
const encoding199 = encoding191

// @peartube/mpv-render-frame-response
const encoding200 = {
  preencode(state, m) {
    state.end++ // max flag is 32 so always one byte

    if (version >= 2 && m.frameData) c.string.preencode(state, m.frameData)
    if (version >= 2 && m.width) c.uint.preencode(state, m.width)
    if (version >= 2 && m.height) c.uint.preencode(state, m.height)
    if (version >= 2 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 2 && m.success) ? 1 : 0) |
      ((version >= 2 && m.hasFrame) ? 2 : 0) |
      ((version >= 2 && m.frameData) ? 4 : 0) |
      ((version >= 2 && m.width) ? 8 : 0) |
      ((version >= 2 && m.height) ? 16 : 0) |
      ((version >= 2 && m.error) ? 32 : 0)

    c.uint.encode(state, flags)

    if (version >= 2 && m.frameData) c.string.encode(state, m.frameData)
    if (version >= 2 && m.width) c.uint.encode(state, m.width)
    if (version >= 2 && m.height) c.uint.encode(state, m.height)
    if (version >= 2 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 2 && (flags & 1) !== 0),
      hasFrame: (version >= 2 && (flags & 2) !== 0),
      frameData: (version >= 2 && (flags & 4) !== 0) ? c.string.decode(state) : null,
      width: (version >= 2 && (flags & 8) !== 0) ? c.uint.decode(state) : 0,
      height: (version >= 2 && (flags & 16) !== 0) ? c.uint.decode(state) : 0,
      error: (version >= 2 && (flags & 32) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/mpv-destroy-request
const encoding201 = encoding191

// @peartube/mpv-destroy-response
const encoding202 = encoding190

// @peartube/search-videos-request
const encoding203 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.query)
    state.end++ // max flag is 2 so always one byte

    if (version >= 3 && m.topK) c.uint.preencode(state, m.topK)
  },
  encode(state, m) {
    const flags =
      ((version >= 3 && m.topK) ? 1 : 0) |
      ((version >= 3 && m.federated) ? 2 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.query)
    c.uint.encode(state, flags)

    if (version >= 3 && m.topK) c.uint.encode(state, m.topK)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      query: r1,
      topK: (version >= 3 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      federated: (version >= 3 && (flags & 2) !== 0)
    }
  }
}

// @peartube/search-videos-response.results
const encoding204_0 = encoding184_0

// @peartube/search-videos-response
const encoding204 = {
  preencode(state, m) {
    encoding204_0.preencode(state, m.results)
  },
  encode(state, m) {
    encoding204_0.encode(state, m.results)
  },
  decode(state) {
    const r0 = encoding204_0.decode(state)

    return {
      results: r0
    }
  }
}

// @peartube/log-watch-event-request
const encoding205 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 4 so always one byte

    if (version >= 3 && m.duration) c.uint.preencode(state, m.duration)
  },
  encode(state, m) {
    const flags =
      ((version >= 3 && m.duration) ? 1 : 0) |
      ((version >= 3 && m.completed) ? 2 : 0) |
      ((version >= 3 && m.share) ? 4 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (version >= 3 && m.duration) c.uint.encode(state, m.duration)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      duration: (version >= 3 && (flags & 1) !== 0) ? c.uint.decode(state) : 0,
      completed: (version >= 3 && (flags & 2) !== 0),
      share: (version >= 3 && (flags & 4) !== 0)
    }
  }
}

// @peartube/log-watch-event-response
const encoding206 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (version >= 3 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 3 && m.success) ? 1 : 0) |
      ((version >= 3 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)

    if (version >= 3 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 3 && (flags & 1) !== 0),
      error: (version >= 3 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/index-video-vectors-request
const encoding207 = encoding60

// @peartube/index-video-vectors-response
const encoding208 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (version >= 4 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 4 && m.success) ? 1 : 0) |
      ((version >= 4 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)

    if (version >= 4 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 4 && (flags & 1) !== 0),
      error: (version >= 4 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/recommendation
const encoding209 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 2 so always one byte

    if (version >= 4 && m.score) c.string.preencode(state, m.score)
    if (version >= 4 && m.reason) c.string.preencode(state, m.reason)
  },
  encode(state, m) {
    const flags =
      ((version >= 4 && m.score) ? 1 : 0) |
      ((version >= 4 && m.reason) ? 2 : 0)

    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (version >= 4 && m.score) c.string.encode(state, m.score)
    if (version >= 4 && m.reason) c.string.encode(state, m.reason)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      score: (version >= 4 && (flags & 1) !== 0) ? c.string.decode(state) : null,
      reason: (version >= 4 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-recommendations-request
const encoding210 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 1 so always one byte

    if (version >= 4 && m.limit) c.uint.preencode(state, m.limit)
  },
  encode(state, m) {
    const flags = (version >= 4 && m.limit) ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (version >= 4 && m.limit) c.uint.encode(state, m.limit)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      limit: (version >= 4 && (flags & 1) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-recommendations-response.recommendations
const encoding211_1 = c.array(c.frame(encoding209))

// @peartube/get-recommendations-response
const encoding211 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte
    encoding211_1.preencode(state, m.recommendations)

    if (version >= 4 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 4 && m.success) ? 1 : 0) |
      ((version >= 4 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)
    encoding211_1.encode(state, m.recommendations)

    if (version >= 4 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 4 && (flags & 1) !== 0),
      recommendations: encoding211_1.decode(state),
      error: (version >= 4 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-video-recommendations-request
const encoding212 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 1 so always one byte

    if (version >= 4 && m.limit) c.uint.preencode(state, m.limit)
  },
  encode(state, m) {
    const flags = (version >= 4 && m.limit) ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (version >= 4 && m.limit) c.uint.encode(state, m.limit)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      limit: (version >= 4 && (flags & 1) !== 0) ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-video-recommendations-response.recommendations
const encoding213_1 = encoding211_1

// @peartube/get-video-recommendations-response
const encoding213 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte
    encoding213_1.preencode(state, m.recommendations)

    if (version >= 4 && m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      ((version >= 4 && m.success) ? 1 : 0) |
      ((version >= 4 && m.error) ? 2 : 0)

    c.uint.encode(state, flags)
    encoding213_1.encode(state, m.recommendations)

    if (version >= 4 && m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (version >= 4 && (flags & 1) !== 0),
      recommendations: encoding213_1.decode(state),
      error: (version >= 4 && (flags & 2) !== 0) ? c.string.decode(state) : null
    }
  }
}

// @peartube/transcode-start-request
const encoding214 = {
  preencode(state, m) {
    c.string.preencode(state, m.sourceUrl)

    if (m.contentType) c.string.preencode(state, m.contentType)
    state.end++ // max flag is 2 so always one byte
    if (m.duration) c.float64.preencode(state, m.duration)
  },
  encode(state, m) {
    const flags =
      (m.contentType ? 1 : 0) |
      (m.duration ? 2 : 0)

    c.string.encode(state, m.sourceUrl)

    if (m.contentType) c.string.encode(state, m.contentType)
    c.uint.encode(state, flags)
    if (m.duration) c.float64.encode(state, m.duration)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      sourceUrl: r0,
      contentType: (flags & 1) !== 0 ? c.string.decode(state) : null,
      duration: (flags & 2) !== 0 ? c.float64.decode(state) : 0
    }
  }
}

// @peartube/transcode-start-response
const encoding215 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.sessionId) c.string.preencode(state, m.sessionId)
    if (m.transcodeUrl) c.string.preencode(state, m.transcodeUrl)
    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.sessionId ? 2 : 0) |
      (m.transcodeUrl ? 4 : 0) |
      (m.error ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.sessionId) c.string.encode(state, m.sessionId)
    if (m.transcodeUrl) c.string.encode(state, m.transcodeUrl)
    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      sessionId: (flags & 2) !== 0 ? c.string.decode(state) : null,
      transcodeUrl: (flags & 4) !== 0 ? c.string.decode(state) : null,
      error: (flags & 8) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/transcode-stop-request
const encoding216 = {
  preencode(state, m) {
    c.uint.preencode(state, flags)
    c.string.preencode(state, m.sessionId)
  },
  encode(state, m) {
    c.uint.encode(state, flags)
    c.string.encode(state, m.sessionId)
  },
  decode(state) {
    const flags = state.start < state.end ? c.uint.decode(state) : 0

    return {
      sessionId: c.string.decode(state)
    }
  }
}

// @peartube/transcode-stop-response
const encoding217 = encoding30

// @peartube/transcode-status-request
const encoding218 = encoding216

// @peartube/transcode-status-response
const encoding219 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.status) c.string.preencode(state, m.status)
    if (m.progress) c.uint.preencode(state, m.progress)
    if (m.bytesWritten) c.uint.preencode(state, m.bytesWritten)
    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.status ? 1 : 0) |
      (m.progress ? 2 : 0) |
      (m.bytesWritten ? 4 : 0) |
      (m.error ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.status) c.string.encode(state, m.status)
    if (m.progress) c.uint.encode(state, m.progress)
    if (m.bytesWritten) c.uint.encode(state, m.bytesWritten)
    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      status: (flags & 1) !== 0 ? c.string.decode(state) : null,
      progress: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      bytesWritten: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      error: (flags & 8) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/event-transcode-progress
const encoding220 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte
    c.string.preencode(state, m.sessionId)

    if (m.percent) c.uint.preencode(state, m.percent)
    if (m.bytesWritten) c.uint.preencode(state, m.bytesWritten)
  },
  encode(state, m) {
    const flags =
      (m.percent ? 1 : 0) |
      (m.bytesWritten ? 2 : 0)

    c.uint.encode(state, flags)
    c.string.encode(state, m.sessionId)

    if (m.percent) c.uint.encode(state, m.percent)
    if (m.bytesWritten) c.uint.encode(state, m.bytesWritten)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      sessionId: c.string.decode(state),
      percent: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      bytesWritten: (flags & 2) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

function setVersion(v) {
  version = v
}

function encode(name, value, v = VERSION) {
  version = v
  return c.encode(getEncoding(name), value)
}

function decode(name, buffer, v = VERSION) {
  version = v
  return c.decode(getEncoding(name), buffer)
}

function getEnum(name) {
  switch (name) {
    default:
      throw new Error('Enum not found ' + name)
  }
}

function getEncoding(name) {
  switch (name) {
    case '@peartube/empty':
      return encoding0
    case '@peartube/error':
      return encoding1
    case '@peartube/identity':
      return encoding2
    case '@peartube/create-identity-request':
      return encoding3
    case '@peartube/create-identity-response':
      return encoding4
    case '@peartube/get-identity-request':
      return encoding5
    case '@peartube/get-identity-response':
      return encoding6
    case '@peartube/get-identities-request':
      return encoding7
    case '@peartube/get-identities-response':
      return encoding8
    case '@peartube/set-active-identity-request':
      return encoding9
    case '@peartube/set-active-identity-response':
      return encoding10
    case '@peartube/recover-identity-request':
      return encoding11
    case '@peartube/recover-identity-response':
      return encoding12
    case '@peartube/channel':
      return encoding13
    case '@peartube/get-channel-request':
      return encoding14
    case '@peartube/get-channel-response':
      return encoding15
    case '@peartube/update-channel-request':
      return encoding16
    case '@peartube/update-channel-response':
      return encoding17
    case '@peartube/video':
      return encoding18
    case '@peartube/list-videos-request':
      return encoding19
    case '@peartube/list-videos-response':
      return encoding20
    case '@peartube/get-video-url-request':
      return encoding21
    case '@peartube/get-video-url-response':
      return encoding22
    case '@peartube/get-video-data-request':
      return encoding23
    case '@peartube/get-video-data-response':
      return encoding24
    case '@peartube/upload-video-request':
      return encoding25
    case '@peartube/upload-video-response':
      return encoding26
    case '@peartube/download-video-request':
      return encoding27
    case '@peartube/download-video-response':
      return encoding28
    case '@peartube/delete-video-request':
      return encoding29
    case '@peartube/delete-video-response':
      return encoding30
    case '@peartube/subscription':
      return encoding31
    case '@peartube/subscribe-channel-request':
      return encoding32
    case '@peartube/subscribe-channel-response':
      return encoding33
    case '@peartube/unsubscribe-channel-request':
      return encoding34
    case '@peartube/unsubscribe-channel-response':
      return encoding35
    case '@peartube/get-subscriptions-request':
      return encoding36
    case '@peartube/get-subscriptions-response':
      return encoding37
    case '@peartube/join-channel-request':
      return encoding38
    case '@peartube/join-channel-response':
      return encoding39
    case '@peartube/feed-entry':
      return encoding40
    case '@peartube/get-public-feed-request':
      return encoding41
    case '@peartube/get-public-feed-response':
      return encoding42
    case '@peartube/refresh-feed-request':
      return encoding43
    case '@peartube/refresh-feed-response':
      return encoding44
    case '@peartube/submit-to-feed-request':
      return encoding45
    case '@peartube/submit-to-feed-response':
      return encoding46
    case '@peartube/unpublish-from-feed-request':
      return encoding47
    case '@peartube/unpublish-from-feed-response':
      return encoding48
    case '@peartube/is-channel-published-request':
      return encoding49
    case '@peartube/is-channel-published-response':
      return encoding50
    case '@peartube/hide-channel-request':
      return encoding51
    case '@peartube/hide-channel-response':
      return encoding52
    case '@peartube/get-channel-meta-request':
      return encoding53
    case '@peartube/get-channel-meta-response':
      return encoding54
    case '@peartube/get-swarm-status-request':
      return encoding55
    case '@peartube/get-swarm-status-response':
      return encoding56
    case '@peartube/prefetch-video-request':
      return encoding57
    case '@peartube/prefetch-video-response':
      return encoding58
    case '@peartube/video-stats':
      return encoding59
    case '@peartube/get-video-stats-request':
      return encoding60
    case '@peartube/get-video-stats-response':
      return encoding61
    case '@peartube/seeding-config':
      return encoding62
    case '@peartube/seeding-status':
      return encoding63
    case '@peartube/get-seeding-status-request':
      return encoding64
    case '@peartube/get-seeding-status-response':
      return encoding65
    case '@peartube/set-seeding-config-request':
      return encoding66
    case '@peartube/set-seeding-config-response':
      return encoding67
    case '@peartube/pin-channel-request':
      return encoding68
    case '@peartube/pin-channel-response':
      return encoding69
    case '@peartube/unpin-channel-request':
      return encoding70
    case '@peartube/unpin-channel-response':
      return encoding71
    case '@peartube/get-pinned-channels-request':
      return encoding72
    case '@peartube/get-pinned-channels-response':
      return encoding73
    case '@peartube/get-storage-stats-request':
      return encoding74
    case '@peartube/get-storage-stats-response':
      return encoding75
    case '@peartube/set-storage-limit-request':
      return encoding76
    case '@peartube/set-storage-limit-response':
      return encoding77
    case '@peartube/clear-cache-request':
      return encoding78
    case '@peartube/clear-cache-response':
      return encoding79
    case '@peartube/get-video-thumbnail-request':
      return encoding80
    case '@peartube/get-video-thumbnail-response':
      return encoding81
    case '@peartube/get-video-metadata-request':
      return encoding82
    case '@peartube/get-video-metadata-response':
      return encoding83
    case '@peartube/set-video-thumbnail-request':
      return encoding84
    case '@peartube/set-video-thumbnail-from-file-request':
      return encoding85
    case '@peartube/set-video-thumbnail-from-file-response':
      return encoding86
    case '@peartube/set-video-thumbnail-response':
      return encoding87
    case '@peartube/status':
      return encoding88
    case '@peartube/get-status-request':
      return encoding89
    case '@peartube/get-status-response':
      return encoding90
    case '@peartube/pick-video-file-request':
      return encoding91
    case '@peartube/pick-video-file-response':
      return encoding92
    case '@peartube/pick-image-file-request':
      return encoding93
    case '@peartube/pick-image-file-response':
      return encoding94
    case '@peartube/get-blob-server-port-request':
      return encoding95
    case '@peartube/get-blob-server-port-response':
      return encoding96
    case '@peartube/device':
      return encoding97
    case '@peartube/create-device-invite-request':
      return encoding98
    case '@peartube/create-device-invite-response':
      return encoding99
    case '@peartube/pair-device-request':
      return encoding100
    case '@peartube/pair-device-response':
      return encoding101
    case '@peartube/retry-sync-channel-request':
      return encoding102
    case '@peartube/retry-sync-channel-response':
      return encoding103
    case '@peartube/list-devices-request':
      return encoding104
    case '@peartube/list-devices-response':
      return encoding105
    case '@peartube/event-ready':
      return encoding106
    case '@peartube/event-error':
      return encoding107
    case '@peartube/event-upload-progress':
      return encoding108
    case '@peartube/event-download-progress':
      return encoding109
    case '@peartube/event-feed-update':
      return encoding110
    case '@peartube/event-log':
      return encoding111
    case '@peartube/event-video-stats':
      return encoding112
    case '@peartube/channel-op-base':
      return encoding113
    case '@peartube/channel-op-update-channel':
      return encoding114
    case '@peartube/channel-op-add-video':
      return encoding115
    case '@peartube/channel-op-update-video':
      return encoding116
    case '@peartube/channel-op-delete-video':
      return encoding117
    case '@peartube/channel-op-add-writer':
      return encoding118
    case '@peartube/channel-op-upsert-writer':
      return encoding119
    case '@peartube/channel-op-remove-writer':
      return encoding120
    case '@peartube/channel-op-add-invite':
      return encoding121
    case '@peartube/channel-op-delete-invite':
      return encoding122
    case '@peartube/channel-op-add-comment':
      return encoding123
    case '@peartube/channel-op-add-reaction':
      return encoding124
    case '@peartube/channel-op-remove-reaction':
      return encoding125
    case '@peartube/channel-op-hide-comment':
      return encoding126
    case '@peartube/channel-op-remove-comment':
      return encoding127
    case '@peartube/channel-op-add-vector-index':
      return encoding128
    case '@peartube/channel-op-log-watch-event':
      return encoding129
    case '@peartube/channel-op-migrate-schema':
      return encoding130
    case '@peartube/add-comment-request':
      return encoding131
    case '@peartube/add-comment-response':
      return encoding132
    case '@peartube/list-comments-request':
      return encoding133
    case '@peartube/comment':
      return encoding134
    case '@peartube/list-comments-response':
      return encoding135
    case '@peartube/hide-comment-request':
      return encoding136
    case '@peartube/hide-comment-response':
      return encoding137
    case '@peartube/remove-comment-request':
      return encoding138
    case '@peartube/remove-comment-response':
      return encoding139
    case '@peartube/reaction-count':
      return encoding140
    case '@peartube/add-reaction-request':
      return encoding141
    case '@peartube/add-reaction-response':
      return encoding142
    case '@peartube/remove-reaction-request':
      return encoding143
    case '@peartube/remove-reaction-response':
      return encoding144
    case '@peartube/get-reactions-request':
      return encoding145
    case '@peartube/get-reactions-response':
      return encoding146
    case '@peartube/cast-device':
      return encoding147
    case '@peartube/cast-available-request':
      return encoding148
    case '@peartube/cast-available-response':
      return encoding149
    case '@peartube/cast-start-discovery-request':
      return encoding150
    case '@peartube/cast-start-discovery-response':
      return encoding151
    case '@peartube/cast-stop-discovery-request':
      return encoding152
    case '@peartube/cast-stop-discovery-response':
      return encoding153
    case '@peartube/cast-get-devices-request':
      return encoding154
    case '@peartube/cast-get-devices-response':
      return encoding155
    case '@peartube/cast-add-manual-device-request':
      return encoding156
    case '@peartube/cast-add-manual-device-response':
      return encoding157
    case '@peartube/cast-connect-request':
      return encoding158
    case '@peartube/cast-connect-response':
      return encoding159
    case '@peartube/cast-disconnect-request':
      return encoding160
    case '@peartube/cast-disconnect-response':
      return encoding161
    case '@peartube/cast-play-request':
      return encoding162
    case '@peartube/cast-play-response':
      return encoding163
    case '@peartube/cast-pause-request':
      return encoding164
    case '@peartube/cast-pause-response':
      return encoding165
    case '@peartube/cast-resume-request':
      return encoding166
    case '@peartube/cast-resume-response':
      return encoding167
    case '@peartube/cast-stop-request':
      return encoding168
    case '@peartube/cast-stop-response':
      return encoding169
    case '@peartube/cast-seek-request':
      return encoding170
    case '@peartube/cast-seek-response':
      return encoding171
    case '@peartube/cast-set-volume-request':
      return encoding172
    case '@peartube/cast-set-volume-response':
      return encoding173
    case '@peartube/cast-get-state-request':
      return encoding174
    case '@peartube/cast-get-state-response':
      return encoding175
    case '@peartube/cast-is-connected-request':
      return encoding176
    case '@peartube/cast-is-connected-response':
      return encoding177
    case '@peartube/event-cast-device-found':
      return encoding178
    case '@peartube/event-cast-device-lost':
      return encoding179
    case '@peartube/event-cast-playback-state':
      return encoding180
    case '@peartube/event-cast-time-update':
      return encoding181
    case '@peartube/search-result':
      return encoding182
    case '@peartube/global-search-videos-request':
      return encoding183
    case '@peartube/global-search-videos-response':
      return encoding184
    case '@peartube/mpv-available-request':
      return encoding185
    case '@peartube/mpv-available-response':
      return encoding186
    case '@peartube/mpv-create-request':
      return encoding187
    case '@peartube/mpv-create-response':
      return encoding188
    case '@peartube/mpv-load-file-request':
      return encoding189
    case '@peartube/mpv-load-file-response':
      return encoding190
    case '@peartube/mpv-play-request':
      return encoding191
    case '@peartube/mpv-play-response':
      return encoding192
    case '@peartube/mpv-pause-request':
      return encoding193
    case '@peartube/mpv-pause-response':
      return encoding194
    case '@peartube/mpv-seek-request':
      return encoding195
    case '@peartube/mpv-seek-response':
      return encoding196
    case '@peartube/mpv-get-state-request':
      return encoding197
    case '@peartube/mpv-get-state-response':
      return encoding198
    case '@peartube/mpv-render-frame-request':
      return encoding199
    case '@peartube/mpv-render-frame-response':
      return encoding200
    case '@peartube/mpv-destroy-request':
      return encoding201
    case '@peartube/mpv-destroy-response':
      return encoding202
    case '@peartube/search-videos-request':
      return encoding203
    case '@peartube/search-videos-response':
      return encoding204
    case '@peartube/log-watch-event-request':
      return encoding205
    case '@peartube/log-watch-event-response':
      return encoding206
    case '@peartube/index-video-vectors-request':
      return encoding207
    case '@peartube/index-video-vectors-response':
      return encoding208
    case '@peartube/recommendation':
      return encoding209
    case '@peartube/get-recommendations-request':
      return encoding210
    case '@peartube/get-recommendations-response':
      return encoding211
    case '@peartube/get-video-recommendations-request':
      return encoding212
    case '@peartube/get-video-recommendations-response':
      return encoding213
    case '@peartube/transcode-start-request':
      return encoding214
    case '@peartube/transcode-start-response':
      return encoding215
    case '@peartube/transcode-stop-request':
      return encoding216
    case '@peartube/transcode-stop-response':
      return encoding217
    case '@peartube/transcode-status-request':
      return encoding218
    case '@peartube/transcode-status-response':
      return encoding219
    case '@peartube/event-transcode-progress':
      return encoding220
    default:
      throw new Error('Encoder not found ' + name)
  }
}

function getStruct(name, v = VERSION) {
  const enc = getEncoding(name)
  return {
    preencode(state, m) {
      version = v
      enc.preencode(state, m)
    },
    encode(state, m) {
      version = v
      enc.encode(state, m)
    },
    decode(state) {
      version = v
      return enc.decode(state)
    }
  }
}

const resolveStruct = getStruct // compat

module.exports = {
  resolveStruct,
  getStruct,
  getEnum,
  getEncoding,
  encode,
  decode,
  setVersion,
  version
}
