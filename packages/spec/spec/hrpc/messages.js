// This file is autogenerated by the hyperschema compiler
// Schema Version: 2
/* eslint-disable camelcase */
/* eslint-disable quotes */
/* eslint-disable space-before-function-paren */

const { c } = require('hyperschema/runtime')

const VERSION = 2

// eslint-disable-next-line no-unused-vars
let version = VERSION

// @peartube/empty
const encoding0 = {
  preencode(state, m) {

  },
  encode(state, m) {

  },
  decode(state) {
    return {
    }
  }
}

// @peartube/error
const encoding1 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.code) c.uint.preencode(state, m.code)
    c.string.preencode(state, m.message)
  },
  encode(state, m) {
    const flags = m.code ? 1 : 0

    c.uint.encode(state, flags)

    if (m.code) c.uint.encode(state, m.code)
    c.string.encode(state, m.message)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      code: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      message: c.string.decode(state)
    }
  }
}

// @peartube/identity
const encoding2 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
    state.end++ // max flag is 32 so always one byte

    if (m.driveKey) c.string.preencode(state, m.driveKey)
    if (m.name) c.string.preencode(state, m.name)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.seedPhrase) c.string.preencode(state, m.seedPhrase)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
  },
  encode(state, m) {
    const flags =
      (m.driveKey ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.avatar ? 4 : 0) |
      (m.seedPhrase ? 8 : 0) |
      (m.createdAt ? 16 : 0) |
      (m.isActive ? 32 : 0)

    c.string.encode(state, m.publicKey)
    c.uint.encode(state, flags)

    if (m.driveKey) c.string.encode(state, m.driveKey)
    if (m.name) c.string.encode(state, m.name)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.seedPhrase) c.string.encode(state, m.seedPhrase)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      publicKey: r0,
      driveKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null,
      seedPhrase: (flags & 8) !== 0 ? c.string.decode(state) : null,
      createdAt: (flags & 16) !== 0 ? c.uint.decode(state) : 0,
      isActive: (flags & 32) !== 0
    }
  }
}

// @peartube/create-identity-request
const encoding3 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.avatar) c.string.preencode(state, m.avatar)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.avatar ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.avatar) c.string.encode(state, m.avatar)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/create-identity-response.identity
const encoding4_0 = c.frame(encoding2)

// @peartube/create-identity-response
const encoding4 = {
  preencode(state, m) {
    encoding4_0.preencode(state, m.identity)
  },
  encode(state, m) {
    encoding4_0.encode(state, m.identity)
  },
  decode(state) {
    const r0 = encoding4_0.decode(state)

    return {
      identity: r0
    }
  }
}

// @peartube/get-identity-request
const encoding5 = encoding0

// @peartube/get-identity-response.identity
const encoding6_0 = encoding4_0

// @peartube/get-identity-response
const encoding6 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.identity) encoding6_0.preencode(state, m.identity)
  },
  encode(state, m) {
    const flags = m.identity ? 1 : 0

    c.uint.encode(state, flags)

    if (m.identity) encoding6_0.encode(state, m.identity)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      identity: (flags & 1) !== 0 ? encoding6_0.decode(state) : null
    }
  }
}

// @peartube/get-identities-request
const encoding7 = encoding0

// @peartube/get-identities-response.identities
const encoding8_0 = c.array(c.frame(encoding2))

// @peartube/get-identities-response
const encoding8 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.identities) encoding8_0.preencode(state, m.identities)
  },
  encode(state, m) {
    const flags = m.identities ? 1 : 0

    c.uint.encode(state, flags)

    if (m.identities) encoding8_0.encode(state, m.identities)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      identities: (flags & 1) !== 0 ? encoding8_0.decode(state) : null
    }
  }
}

// @peartube/set-active-identity-request
const encoding9 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
  },
  encode(state, m) {
    c.string.encode(state, m.publicKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      publicKey: r0
    }
  }
}

// @peartube/set-active-identity-response
const encoding10 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = m.success ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0
    }
  }
}

// @peartube/recover-identity-request
const encoding11 = {
  preencode(state, m) {
    c.string.preencode(state, m.seedPhrase)
  },
  encode(state, m) {
    c.string.encode(state, m.seedPhrase)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      seedPhrase: r0
    }
  }
}

// @peartube/recover-identity-response.identity
const encoding12_0 = encoding4_0

// @peartube/recover-identity-response
const encoding12 = {
  preencode(state, m) {
    encoding12_0.preencode(state, m.identity)
  },
  encode(state, m) {
    encoding12_0.encode(state, m.identity)
  },
  decode(state) {
    const r0 = encoding12_0.decode(state)

    return {
      identity: r0
    }
  }
}

// @peartube/channel
const encoding13 = {
  preencode(state, m) {
    c.string.preencode(state, m.publicKey)
    state.end++ // max flag is 16 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
    if (m.subscriberCount) c.uint.preencode(state, m.subscriberCount)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.avatar ? 4 : 0) |
      (m.videoCount ? 8 : 0) |
      (m.subscriberCount ? 16 : 0)

    c.string.encode(state, m.publicKey)
    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
    if (m.subscriberCount) c.uint.encode(state, m.subscriberCount)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      publicKey: r0,
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      subscriberCount: (flags & 16) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-channel-request
const encoding14 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.publicKey) c.string.preencode(state, m.publicKey)
  },
  encode(state, m) {
    const flags = m.publicKey ? 1 : 0

    c.uint.encode(state, flags)

    if (m.publicKey) c.string.encode(state, m.publicKey)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      publicKey: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-channel-response.channel
const encoding15_0 = c.frame(encoding13)

// @peartube/get-channel-response
const encoding15 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.channel) encoding15_0.preencode(state, m.channel)
  },
  encode(state, m) {
    const flags = m.channel ? 1 : 0

    c.uint.encode(state, flags)

    if (m.channel) encoding15_0.encode(state, m.channel)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channel: (flags & 1) !== 0 ? encoding15_0.decode(state) : null
    }
  }
}

// @peartube/update-channel-request
const encoding16 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.avatar) c.string.preencode(state, m.avatar)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.avatar ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.avatar) c.string.encode(state, m.avatar)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/update-channel-response.channel
const encoding17_0 = encoding15_0

// @peartube/update-channel-response
const encoding17 = {
  preencode(state, m) {
    encoding17_0.preencode(state, m.channel)
  },
  encode(state, m) {
    encoding17_0.encode(state, m.channel)
  },
  decode(state) {
    const r0 = encoding17_0.decode(state)

    return {
      channel: r0
    }
  }
}

// @peartube/video
const encoding18 = {
  preencode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.path ? 2 : 0) |
      (m.duration ? 4 : 0) |
      (m.thumbnail ? 8 : 0) |
      (m.channelKey ? 16 : 0) |
      (m.channelName ? 32 : 0) |
      (m.createdAt ? 64 : 0) |
      (m.views ? 128 : 0) |
      (m.category ? 256 : 0)

    c.string.preencode(state, m.id)
    c.string.preencode(state, m.title)
    c.uint.preencode(state, flags)

    if (m.description) c.string.preencode(state, m.description)
    if (m.path) c.string.preencode(state, m.path)
    if (m.duration) c.uint.preencode(state, m.duration)
    if (m.thumbnail) c.string.preencode(state, m.thumbnail)
    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
    if (m.views) c.uint.preencode(state, m.views)
    if (m.category) c.string.preencode(state, m.category)
  },
  encode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.path ? 2 : 0) |
      (m.duration ? 4 : 0) |
      (m.thumbnail ? 8 : 0) |
      (m.channelKey ? 16 : 0) |
      (m.channelName ? 32 : 0) |
      (m.createdAt ? 64 : 0) |
      (m.views ? 128 : 0) |
      (m.category ? 256 : 0)

    c.string.encode(state, m.id)
    c.string.encode(state, m.title)
    c.uint.encode(state, flags)

    if (m.description) c.string.encode(state, m.description)
    if (m.path) c.string.encode(state, m.path)
    if (m.duration) c.uint.encode(state, m.duration)
    if (m.thumbnail) c.string.encode(state, m.thumbnail)
    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
    if (m.views) c.uint.encode(state, m.views)
    if (m.category) c.string.encode(state, m.category)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      id: r0,
      title: r1,
      description: (flags & 1) !== 0 ? c.string.decode(state) : null,
      path: (flags & 2) !== 0 ? c.string.decode(state) : null,
      duration: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      thumbnail: (flags & 8) !== 0 ? c.string.decode(state) : null,
      channelKey: (flags & 16) !== 0 ? c.string.decode(state) : null,
      channelName: (flags & 32) !== 0 ? c.string.decode(state) : null,
      createdAt: (flags & 64) !== 0 ? c.uint.decode(state) : 0,
      views: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      category: (flags & 256) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/list-videos-request
const encoding19 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
    if (m.limit) c.uint.preencode(state, m.limit)
    if (m.offset) c.uint.preencode(state, m.offset)
  },
  encode(state, m) {
    const flags =
      (m.channelKey ? 1 : 0) |
      (m.publicBeeKey ? 2 : 0) |
      (m.limit ? 4 : 0) |
      (m.offset ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
    if (m.limit) c.uint.encode(state, m.limit)
    if (m.offset) c.uint.encode(state, m.offset)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channelKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      publicBeeKey: (flags & 2) !== 0 ? c.string.decode(state) : null,
      limit: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      offset: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/list-videos-response.videos
const encoding20_0 = c.array(c.frame(encoding18))

// @peartube/list-videos-response
const encoding20 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.videos) encoding20_0.preencode(state, m.videos)
  },
  encode(state, m) {
    const flags = m.videos ? 1 : 0

    c.uint.encode(state, flags)

    if (m.videos) encoding20_0.encode(state, m.videos)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      videos: (flags & 1) !== 0 ? encoding20_0.decode(state) : null
    }
  }
}

// @peartube/get-video-url-request
const encoding21 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 1 so always one byte

    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags = m.publicBeeKey ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      publicBeeKey: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-video-url-response
const encoding22 = {
  preencode(state, m) {
    c.string.preencode(state, m.url)
  },
  encode(state, m) {
    c.string.encode(state, m.url)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      url: r0
    }
  }
}

// @peartube/get-video-data-request
const encoding23 = encoding21

// @peartube/get-video-data-response.video
const encoding24_0 = c.frame(encoding18)

// @peartube/get-video-data-response
const encoding24 = {
  preencode(state, m) {
    encoding24_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding24_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding24_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/upload-video-request
const encoding25 = {
  preencode(state, m) {
    c.string.preencode(state, m.filePath)
    c.string.preencode(state, m.title)
    state.end++ // max flag is 4 so always one byte

    if (m.description) c.string.preencode(state, m.description)
    if (m.category) c.string.preencode(state, m.category)
  },
  encode(state, m) {
    const flags =
      (m.description ? 1 : 0) |
      (m.category ? 2 : 0) |
      (m.skipThumbnailGeneration ? 4 : 0)

    c.string.encode(state, m.filePath)
    c.string.encode(state, m.title)
    c.uint.encode(state, flags)

    if (m.description) c.string.encode(state, m.description)
    if (m.category) c.string.encode(state, m.category)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      filePath: r0,
      title: r1,
      description: (flags & 1) !== 0 ? c.string.decode(state) : null,
      category: (flags & 2) !== 0 ? c.string.decode(state) : null,
      skipThumbnailGeneration: (flags & 4) !== 0
    }
  }
}

// @peartube/upload-video-response.video
const encoding26_0 = encoding24_0

// @peartube/upload-video-response
const encoding26 = {
  preencode(state, m) {
    encoding26_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding26_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding26_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/download-video-request
const encoding27 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.destPath)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.destPath)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      destPath: r2
    }
  }
}

// @peartube/download-video-response
const encoding28 = {
  preencode(state, m) {
    state.end++ // max flag is 16 so always one byte

    if (m.filePath) c.string.preencode(state, m.filePath)
    if (m.size) c.uint.preencode(state, m.size)
    if (m.error) c.string.preencode(state, m.error)
    if (m.data) c.string.preencode(state, m.data)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.filePath ? 2 : 0) |
      (m.size ? 4 : 0) |
      (m.error ? 8 : 0) |
      (m.data ? 16 : 0)

    c.uint.encode(state, flags)

    if (m.filePath) c.string.encode(state, m.filePath)
    if (m.size) c.uint.encode(state, m.size)
    if (m.error) c.string.encode(state, m.error)
    if (m.data) c.string.encode(state, m.data)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      filePath: (flags & 2) !== 0 ? c.string.decode(state) : null,
      size: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      error: (flags & 8) !== 0 ? c.string.decode(state) : null,
      data: (flags & 16) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/delete-video-request
const encoding29 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
  },
  encode(state, m) {
    c.string.encode(state, m.videoId)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      videoId: r0
    }
  }
}

// @peartube/delete-video-response
const encoding30 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.error ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      error: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/subscription
const encoding31 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 4 so always one byte

    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.subscribedAt) c.uint.preencode(state, m.subscribedAt)
  },
  encode(state, m) {
    const flags =
      (m.channelName ? 1 : 0) |
      (m.avatar ? 2 : 0) |
      (m.subscribedAt ? 4 : 0)

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.subscribedAt) c.uint.encode(state, m.subscribedAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      channelName: (flags & 1) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 2) !== 0 ? c.string.decode(state) : null,
      subscribedAt: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/subscribe-channel-request
const encoding32 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      channelKey: r0
    }
  }
}

// @peartube/subscribe-channel-response
const encoding33 = encoding10

// @peartube/unsubscribe-channel-request
const encoding34 = encoding32

// @peartube/unsubscribe-channel-response
const encoding35 = encoding10

// @peartube/get-subscriptions-request
const encoding36 = encoding0

// @peartube/get-subscriptions-response.subscriptions
const encoding37_0 = c.array(c.frame(encoding31))

// @peartube/get-subscriptions-response
const encoding37 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.subscriptions) encoding37_0.preencode(state, m.subscriptions)
  },
  encode(state, m) {
    const flags = m.subscriptions ? 1 : 0

    c.uint.encode(state, flags)

    if (m.subscriptions) encoding37_0.encode(state, m.subscriptions)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      subscriptions: (flags & 1) !== 0 ? encoding37_0.decode(state) : null
    }
  }
}

// @peartube/join-channel-request
const encoding38 = encoding32

// @peartube/join-channel-response
const encoding39 = encoding10

// @peartube/feed-entry
const encoding40 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 16 so always one byte

    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
    if (m.channelName) c.string.preencode(state, m.channelName)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
    if (m.peerCount) c.uint.preencode(state, m.peerCount)
    if (m.lastSeen) c.uint.preencode(state, m.lastSeen)
  },
  encode(state, m) {
    const flags =
      (m.publicBeeKey ? 1 : 0) |
      (m.channelName ? 2 : 0) |
      (m.videoCount ? 4 : 0) |
      (m.peerCount ? 8 : 0) |
      (m.lastSeen ? 16 : 0)

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
    if (m.channelName) c.string.encode(state, m.channelName)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
    if (m.peerCount) c.uint.encode(state, m.peerCount)
    if (m.lastSeen) c.uint.encode(state, m.lastSeen)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      publicBeeKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      channelName: (flags & 2) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      peerCount: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      lastSeen: (flags & 16) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-public-feed-request
const encoding41 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.limit) c.uint.preencode(state, m.limit)
  },
  encode(state, m) {
    const flags = m.limit ? 1 : 0

    c.uint.encode(state, flags)

    if (m.limit) c.uint.encode(state, m.limit)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      limit: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-public-feed-response.entries
const encoding42_0 = c.array(c.frame(encoding40))

// @peartube/get-public-feed-response
const encoding42 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.entries) encoding42_0.preencode(state, m.entries)
  },
  encode(state, m) {
    const flags = m.entries ? 1 : 0

    c.uint.encode(state, flags)

    if (m.entries) encoding42_0.encode(state, m.entries)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      entries: (flags & 1) !== 0 ? encoding42_0.decode(state) : null
    }
  }
}

// @peartube/refresh-feed-request
const encoding43 = encoding0

// @peartube/refresh-feed-response
const encoding44 = encoding10

// @peartube/submit-to-feed-request
const encoding45 = encoding0

// @peartube/submit-to-feed-response
const encoding46 = encoding10

// @peartube/unpublish-from-feed-request
const encoding47 = encoding0

// @peartube/unpublish-from-feed-response
const encoding48 = encoding10

// @peartube/is-channel-published-request
const encoding49 = encoding0

// @peartube/is-channel-published-response
const encoding50 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte
  },
  encode(state, m) {
    const flags = m.published ? 1 : 0

    c.uint.encode(state, flags)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      published: (flags & 1) !== 0
    }
  }
}

// @peartube/hide-channel-request
const encoding51 = encoding32

// @peartube/hide-channel-response
const encoding52 = encoding10

// @peartube/get-channel-meta-request
const encoding53 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 1 so always one byte

    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags = m.publicBeeKey ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      publicBeeKey: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-channel-meta-response
const encoding54 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
  },
  encode(state, m) {
    const flags =
      (m.name ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.videoCount ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      name: (flags & 1) !== 0 ? c.string.decode(state) : null,
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-swarm-status-request
const encoding55 = encoding0

// @peartube/get-swarm-status-response
const encoding56 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.peerCount) c.uint.preencode(state, m.peerCount)
  },
  encode(state, m) {
    const flags =
      (m.connected ? 1 : 0) |
      (m.peerCount ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.peerCount) c.uint.encode(state, m.peerCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      connected: (flags & 1) !== 0,
      peerCount: (flags & 2) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/prefetch-video-request
const encoding57 = encoding21

// @peartube/prefetch-video-response
const encoding58 = encoding10

// @peartube/video-stats
const encoding59 = {
  preencode(state, m) {
    const flags =
      (m.videoId ? 1 : 0) |
      (m.channelKey ? 2 : 0) |
      (m.status ? 4 : 0) |
      (m.progress ? 8 : 0) |
      (m.totalBlocks ? 16 : 0) |
      (m.downloadedBlocks ? 32 : 0) |
      (m.totalBytes ? 64 : 0) |
      (m.downloadedBytes ? 128 : 0) |
      (m.peerCount ? 256 : 0) |
      (m.speedMBps ? 512 : 0) |
      (m.uploadSpeedMBps ? 1024 : 0) |
      (m.elapsed ? 2048 : 0) |
      (m.isComplete ? 4096 : 0)

    c.uint.preencode(state, flags)

    if (m.videoId) c.string.preencode(state, m.videoId)
    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.status) c.string.preencode(state, m.status)
    if (m.progress) c.uint.preencode(state, m.progress)
    if (m.totalBlocks) c.uint.preencode(state, m.totalBlocks)
    if (m.downloadedBlocks) c.uint.preencode(state, m.downloadedBlocks)
    if (m.totalBytes) c.uint.preencode(state, m.totalBytes)
    if (m.downloadedBytes) c.uint.preencode(state, m.downloadedBytes)
    if (m.peerCount) c.uint.preencode(state, m.peerCount)
    if (m.speedMBps) c.string.preencode(state, m.speedMBps)
    if (m.uploadSpeedMBps) c.string.preencode(state, m.uploadSpeedMBps)
    if (m.elapsed) c.uint.preencode(state, m.elapsed)
  },
  encode(state, m) {
    const flags =
      (m.videoId ? 1 : 0) |
      (m.channelKey ? 2 : 0) |
      (m.status ? 4 : 0) |
      (m.progress ? 8 : 0) |
      (m.totalBlocks ? 16 : 0) |
      (m.downloadedBlocks ? 32 : 0) |
      (m.totalBytes ? 64 : 0) |
      (m.downloadedBytes ? 128 : 0) |
      (m.peerCount ? 256 : 0) |
      (m.speedMBps ? 512 : 0) |
      (m.uploadSpeedMBps ? 1024 : 0) |
      (m.elapsed ? 2048 : 0) |
      (m.isComplete ? 4096 : 0)

    c.uint.encode(state, flags)

    if (m.videoId) c.string.encode(state, m.videoId)
    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.status) c.string.encode(state, m.status)
    if (m.progress) c.uint.encode(state, m.progress)
    if (m.totalBlocks) c.uint.encode(state, m.totalBlocks)
    if (m.downloadedBlocks) c.uint.encode(state, m.downloadedBlocks)
    if (m.totalBytes) c.uint.encode(state, m.totalBytes)
    if (m.downloadedBytes) c.uint.encode(state, m.downloadedBytes)
    if (m.peerCount) c.uint.encode(state, m.peerCount)
    if (m.speedMBps) c.string.encode(state, m.speedMBps)
    if (m.uploadSpeedMBps) c.string.encode(state, m.uploadSpeedMBps)
    if (m.elapsed) c.uint.encode(state, m.elapsed)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      videoId: (flags & 1) !== 0 ? c.string.decode(state) : null,
      channelKey: (flags & 2) !== 0 ? c.string.decode(state) : null,
      status: (flags & 4) !== 0 ? c.string.decode(state) : null,
      progress: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      totalBlocks: (flags & 16) !== 0 ? c.uint.decode(state) : 0,
      downloadedBlocks: (flags & 32) !== 0 ? c.uint.decode(state) : 0,
      totalBytes: (flags & 64) !== 0 ? c.uint.decode(state) : 0,
      downloadedBytes: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      peerCount: (flags & 256) !== 0 ? c.uint.decode(state) : 0,
      speedMBps: (flags & 512) !== 0 ? c.string.decode(state) : null,
      uploadSpeedMBps: (flags & 1024) !== 0 ? c.string.decode(state) : null,
      elapsed: (flags & 2048) !== 0 ? c.uint.decode(state) : 0,
      isComplete: (flags & 4096) !== 0
    }
  }
}

// @peartube/get-video-stats-request
const encoding60 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      channelKey: r0,
      videoId: r1
    }
  }
}

// @peartube/get-video-stats-response.stats
const encoding61_0 = c.frame(encoding59)

// @peartube/get-video-stats-response
const encoding61 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.stats) encoding61_0.preencode(state, m.stats)
  },
  encode(state, m) {
    const flags = m.stats ? 1 : 0

    c.uint.encode(state, flags)

    if (m.stats) encoding61_0.encode(state, m.stats)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      stats: (flags & 1) !== 0 ? encoding61_0.decode(state) : null
    }
  }
}

// @peartube/seeding-config
const encoding62 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.maxStorage) c.uint.preencode(state, m.maxStorage)
    if (m.maxBandwidth) c.uint.preencode(state, m.maxBandwidth)
  },
  encode(state, m) {
    const flags =
      (m.enabled ? 1 : 0) |
      (m.maxStorage ? 2 : 0) |
      (m.maxBandwidth ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.maxStorage) c.uint.encode(state, m.maxStorage)
    if (m.maxBandwidth) c.uint.encode(state, m.maxBandwidth)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      enabled: (flags & 1) !== 0,
      maxStorage: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      maxBandwidth: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/seeding-status
const encoding63 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.usedStorage) c.uint.preencode(state, m.usedStorage)
    if (m.maxStorage) c.uint.preencode(state, m.maxStorage)
    if (m.seedingCount) c.uint.preencode(state, m.seedingCount)
  },
  encode(state, m) {
    const flags =
      (m.enabled ? 1 : 0) |
      (m.usedStorage ? 2 : 0) |
      (m.maxStorage ? 4 : 0) |
      (m.seedingCount ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.usedStorage) c.uint.encode(state, m.usedStorage)
    if (m.maxStorage) c.uint.encode(state, m.maxStorage)
    if (m.seedingCount) c.uint.encode(state, m.seedingCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      enabled: (flags & 1) !== 0,
      usedStorage: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      maxStorage: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      seedingCount: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-seeding-status-request
const encoding64 = encoding0

// @peartube/get-seeding-status-response.status
const encoding65_0 = c.frame(encoding63)

// @peartube/get-seeding-status-response
const encoding65 = {
  preencode(state, m) {
    encoding65_0.preencode(state, m.status)
  },
  encode(state, m) {
    encoding65_0.encode(state, m.status)
  },
  decode(state) {
    const r0 = encoding65_0.decode(state)

    return {
      status: r0
    }
  }
}

// @peartube/set-seeding-config-request.config
const encoding66_0 = c.frame(encoding62)

// @peartube/set-seeding-config-request
const encoding66 = {
  preencode(state, m) {
    encoding66_0.preencode(state, m.config)
  },
  encode(state, m) {
    encoding66_0.encode(state, m.config)
  },
  decode(state) {
    const r0 = encoding66_0.decode(state)

    return {
      config: r0
    }
  }
}

// @peartube/set-seeding-config-response
const encoding67 = encoding10

// @peartube/pin-channel-request
const encoding68 = encoding32

// @peartube/pin-channel-response
const encoding69 = encoding10

// @peartube/unpin-channel-request
const encoding70 = encoding32

// @peartube/unpin-channel-response
const encoding71 = encoding10

// @peartube/get-pinned-channels-request
const encoding72 = encoding0

// @peartube/get-pinned-channels-response.channels
const encoding73_0 = c.array(c.string)

// @peartube/get-pinned-channels-response
const encoding73 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.channels) encoding73_0.preencode(state, m.channels)
  },
  encode(state, m) {
    const flags = m.channels ? 1 : 0

    c.uint.encode(state, flags)

    if (m.channels) encoding73_0.encode(state, m.channels)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      channels: (flags & 1) !== 0 ? encoding73_0.decode(state) : null
    }
  }
}

// @peartube/get-storage-stats-request
const encoding74 = encoding0

// @peartube/get-storage-stats-response
const encoding75 = {
  preencode(state, m) {
    c.uint.preencode(state, m.usedBytes)
    c.uint.preencode(state, m.maxBytes)
    c.string.preencode(state, m.usedGB)
    c.uint.preencode(state, m.maxGB)
    c.uint.preencode(state, m.seedCount)
    c.uint.preencode(state, m.pinnedCount)
  },
  encode(state, m) {
    c.uint.encode(state, m.usedBytes)
    c.uint.encode(state, m.maxBytes)
    c.string.encode(state, m.usedGB)
    c.uint.encode(state, m.maxGB)
    c.uint.encode(state, m.seedCount)
    c.uint.encode(state, m.pinnedCount)
  },
  decode(state) {
    const r0 = c.uint.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.string.decode(state)
    const r3 = c.uint.decode(state)
    const r4 = c.uint.decode(state)
    const r5 = c.uint.decode(state)

    return {
      usedBytes: r0,
      maxBytes: r1,
      usedGB: r2,
      maxGB: r3,
      seedCount: r4,
      pinnedCount: r5
    }
  }
}

// @peartube/set-storage-limit-request
const encoding76 = {
  preencode(state, m) {
    c.uint.preencode(state, m.maxGB)
  },
  encode(state, m) {
    c.uint.encode(state, m.maxGB)
  },
  decode(state) {
    const r0 = c.uint.decode(state)

    return {
      maxGB: r0
    }
  }
}

// @peartube/set-storage-limit-response
const encoding77 = encoding10

// @peartube/clear-cache-request
const encoding78 = encoding0

// @peartube/clear-cache-response
const encoding79 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.clearedBytes) c.uint.preencode(state, m.clearedBytes)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.clearedBytes ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.clearedBytes) c.uint.encode(state, m.clearedBytes)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      clearedBytes: (flags & 2) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-video-thumbnail-request
const encoding80 = encoding60

// @peartube/get-video-thumbnail-response
const encoding81 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.url) c.string.preencode(state, m.url)
    if (m.dataUrl) c.string.preencode(state, m.dataUrl)
  },
  encode(state, m) {
    const flags =
      (m.url ? 1 : 0) |
      (m.dataUrl ? 2 : 0) |
      (m.exists ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.url) c.string.encode(state, m.url)
    if (m.dataUrl) c.string.encode(state, m.dataUrl)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      url: (flags & 1) !== 0 ? c.string.decode(state) : null,
      dataUrl: (flags & 2) !== 0 ? c.string.decode(state) : null,
      exists: (flags & 4) !== 0
    }
  }
}

// @peartube/get-video-metadata-request
const encoding82 = encoding60

// @peartube/get-video-metadata-response.video
const encoding83_0 = encoding24_0

// @peartube/get-video-metadata-response
const encoding83 = {
  preencode(state, m) {
    encoding83_0.preencode(state, m.video)
  },
  encode(state, m) {
    encoding83_0.encode(state, m.video)
  },
  decode(state) {
    const r0 = encoding83_0.decode(state)

    return {
      video: r0
    }
  }
}

// @peartube/set-video-thumbnail-request
const encoding84 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.imageData)
    state.end++ // max flag is 1 so always one byte

    if (m.mimeType) c.string.preencode(state, m.mimeType)
  },
  encode(state, m) {
    const flags = m.mimeType ? 1 : 0

    c.string.encode(state, m.videoId)
    c.string.encode(state, m.imageData)
    c.uint.encode(state, flags)

    if (m.mimeType) c.string.encode(state, m.mimeType)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      imageData: r1,
      mimeType: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/set-video-thumbnail-from-file-request
const encoding85 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.filePath)
  },
  encode(state, m) {
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.filePath)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      videoId: r0,
      filePath: r1
    }
  }
}

// @peartube/set-video-thumbnail-from-file-response
const encoding86 = encoding10

// @peartube/set-video-thumbnail-response
const encoding87 = encoding10

// @peartube/status
const encoding88 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.blobServerPort) c.uint.preencode(state, m.blobServerPort)
  },
  encode(state, m) {
    const flags =
      (m.ready ? 1 : 0) |
      (m.hasIdentity ? 2 : 0) |
      (m.blobServerPort ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.blobServerPort) c.uint.encode(state, m.blobServerPort)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      ready: (flags & 1) !== 0,
      hasIdentity: (flags & 2) !== 0,
      blobServerPort: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-status-request
const encoding89 = encoding0

// @peartube/get-status-response.status
const encoding90_0 = c.frame(encoding88)

// @peartube/get-status-response
const encoding90 = {
  preencode(state, m) {
    encoding90_0.preencode(state, m.status)
  },
  encode(state, m) {
    encoding90_0.encode(state, m.status)
  },
  decode(state) {
    const r0 = encoding90_0.decode(state)

    return {
      status: r0
    }
  }
}

// @peartube/pick-video-file-request
const encoding91 = encoding0

// @peartube/pick-video-file-response
const encoding92 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.filePath) c.string.preencode(state, m.filePath)
    if (m.name) c.string.preencode(state, m.name)
    if (m.size) c.uint.preencode(state, m.size)
  },
  encode(state, m) {
    const flags =
      (m.filePath ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.size ? 4 : 0) |
      (m.cancelled ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.filePath) c.string.encode(state, m.filePath)
    if (m.name) c.string.encode(state, m.name)
    if (m.size) c.uint.encode(state, m.size)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      filePath: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      size: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      cancelled: (flags & 8) !== 0
    }
  }
}

// @peartube/pick-image-file-request
const encoding93 = encoding0

// @peartube/pick-image-file-response
const encoding94 = {
  preencode(state, m) {
    state.end++ // max flag is 16 so always one byte

    if (m.filePath) c.string.preencode(state, m.filePath)
    if (m.name) c.string.preencode(state, m.name)
    if (m.size) c.uint.preencode(state, m.size)
    if (m.dataUrl) c.string.preencode(state, m.dataUrl)
  },
  encode(state, m) {
    const flags =
      (m.filePath ? 1 : 0) |
      (m.name ? 2 : 0) |
      (m.size ? 4 : 0) |
      (m.dataUrl ? 8 : 0) |
      (m.cancelled ? 16 : 0)

    c.uint.encode(state, flags)

    if (m.filePath) c.string.encode(state, m.filePath)
    if (m.name) c.string.encode(state, m.name)
    if (m.size) c.uint.encode(state, m.size)
    if (m.dataUrl) c.string.encode(state, m.dataUrl)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      filePath: (flags & 1) !== 0 ? c.string.decode(state) : null,
      name: (flags & 2) !== 0 ? c.string.decode(state) : null,
      size: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      dataUrl: (flags & 8) !== 0 ? c.string.decode(state) : null,
      cancelled: (flags & 16) !== 0
    }
  }
}

// @peartube/get-blob-server-port-request
const encoding95 = encoding0

// @peartube/get-blob-server-port-response
const encoding96 = {
  preencode(state, m) {
    c.uint.preencode(state, m.port)
  },
  encode(state, m) {
    c.uint.encode(state, m.port)
  },
  decode(state) {
    const r0 = c.uint.decode(state)

    return {
      port: r0
    }
  }
}

// @peartube/device
const encoding97 = {
  preencode(state, m) {
    c.string.preencode(state, m.keyHex)
    state.end++ // max flag is 8 so always one byte

    if (m.role) c.string.preencode(state, m.role)
    if (m.deviceName) c.string.preencode(state, m.deviceName)
    if (m.addedAt) c.uint.preencode(state, m.addedAt)
    if (m.blobDriveKey) c.string.preencode(state, m.blobDriveKey)
  },
  encode(state, m) {
    const flags =
      (m.role ? 1 : 0) |
      (m.deviceName ? 2 : 0) |
      (m.addedAt ? 4 : 0) |
      (m.blobDriveKey ? 8 : 0)

    c.string.encode(state, m.keyHex)
    c.uint.encode(state, flags)

    if (m.role) c.string.encode(state, m.role)
    if (m.deviceName) c.string.encode(state, m.deviceName)
    if (m.addedAt) c.uint.encode(state, m.addedAt)
    if (m.blobDriveKey) c.string.encode(state, m.blobDriveKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      keyHex: r0,
      role: (flags & 1) !== 0 ? c.string.decode(state) : null,
      deviceName: (flags & 2) !== 0 ? c.string.decode(state) : null,
      addedAt: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      blobDriveKey: (flags & 8) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/create-device-invite-request
const encoding98 = encoding32

// @peartube/create-device-invite-response
const encoding99 = {
  preencode(state, m) {
    c.string.preencode(state, m.inviteCode)
  },
  encode(state, m) {
    c.string.encode(state, m.inviteCode)
  },
  decode(state) {
    const r0 = c.string.decode(state)

    return {
      inviteCode: r0
    }
  }
}

// @peartube/pair-device-request
const encoding100 = {
  preencode(state, m) {
    c.string.preencode(state, m.inviteCode)
    state.end++ // max flag is 1 so always one byte

    if (m.deviceName) c.string.preencode(state, m.deviceName)
  },
  encode(state, m) {
    const flags = m.deviceName ? 1 : 0

    c.string.encode(state, m.inviteCode)
    c.uint.encode(state, flags)

    if (m.deviceName) c.string.encode(state, m.deviceName)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      inviteCode: r0,
      deviceName: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/pair-device-response
const encoding101 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte
    c.string.preencode(state, m.channelKey)

    if (m.syncState) c.string.preencode(state, m.syncState)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.syncState ? 2 : 0) |
      (m.videoCount ? 4 : 0)

    c.uint.encode(state, flags)
    c.string.encode(state, m.channelKey)

    if (m.syncState) c.string.encode(state, m.syncState)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      channelKey: c.string.decode(state),
      syncState: (flags & 2) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/retry-sync-channel-request
const encoding102 = encoding32

// @peartube/retry-sync-channel-response
const encoding103 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.state) c.string.preencode(state, m.state)
    if (m.videoCount) c.uint.preencode(state, m.videoCount)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.state ? 2 : 0) |
      (m.videoCount ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.state) c.string.encode(state, m.state)
    if (m.videoCount) c.uint.encode(state, m.videoCount)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      state: (flags & 2) !== 0 ? c.string.decode(state) : null,
      videoCount: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/list-devices-request
const encoding104 = encoding32

// @peartube/list-devices-response.devices
const encoding105_0 = c.array(c.frame(encoding97))

// @peartube/list-devices-response
const encoding105 = {
  preencode(state, m) {
    encoding105_0.preencode(state, m.devices)
  },
  encode(state, m) {
    encoding105_0.encode(state, m.devices)
  },
  decode(state) {
    const r0 = encoding105_0.decode(state)

    return {
      devices: r0
    }
  }
}

// @peartube/search-result
const encoding106 = {
  preencode(state, m) {
    c.string.preencode(state, m.id)
    state.end++ // max flag is 2 so always one byte

    if (m.score) c.string.preencode(state, m.score)
    if (m.metadata) c.string.preencode(state, m.metadata)
  },
  encode(state, m) {
    const flags =
      (m.score ? 1 : 0) |
      (m.metadata ? 2 : 0)

    c.string.encode(state, m.id)
    c.uint.encode(state, flags)

    if (m.score) c.string.encode(state, m.score)
    if (m.metadata) c.string.encode(state, m.metadata)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      id: r0,
      score: (flags & 1) !== 0 ? c.string.decode(state) : null,
      metadata: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/search-videos-request
const encoding107 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.query)
    state.end++ // max flag is 2 so always one byte

    if (m.topK) c.uint.preencode(state, m.topK)
  },
  encode(state, m) {
    const flags =
      (m.topK ? 1 : 0) |
      (m.federated ? 2 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.query)
    c.uint.encode(state, flags)

    if (m.topK) c.uint.encode(state, m.topK)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      query: r1,
      topK: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      federated: (flags & 2) !== 0
    }
  }
}

// @peartube/search-videos-response.results
const encoding108_0 = c.array(c.frame(encoding106))

// @peartube/search-videos-response
const encoding108 = {
  preencode(state, m) {
    encoding108_0.preencode(state, m.results)
  },
  encode(state, m) {
    encoding108_0.encode(state, m.results)
  },
  decode(state) {
    const r0 = encoding108_0.decode(state)

    return {
      results: r0
    }
  }
}

// @peartube/index-video-vectors-request
const encoding109 = encoding60

// @peartube/index-video-vectors-response
const encoding110 = encoding30

// @peartube/comment
const encoding111 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    c.string.preencode(state, m.text)
    c.string.preencode(state, m.authorKeyHex)
    state.end++ // max flag is 4 so always one byte

    if (m.timestamp) c.uint.preencode(state, m.timestamp)
    if (m.parentId) c.string.preencode(state, m.parentId)
  },
  encode(state, m) {
    const flags =
      (m.timestamp ? 1 : 0) |
      (m.parentId ? 2 : 0) |
      ((version >= 2 && m.isAdmin) ? 4 : 0)

    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.string.encode(state, m.text)
    c.string.encode(state, m.authorKeyHex)
    c.uint.encode(state, flags)

    if (m.timestamp) c.uint.encode(state, m.timestamp)
    if (m.parentId) c.string.encode(state, m.parentId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const r3 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      commentId: r1,
      text: r2,
      authorKeyHex: r3,
      timestamp: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      parentId: (flags & 2) !== 0 ? c.string.decode(state) : null,
      isAdmin: (version >= 2 && (flags & 4) !== 0)
    }
  }
}

// @peartube/add-comment-request
const encoding112 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.text)
    state.end++ // max flag is 4 so always one byte

    if (m.parentId) c.string.preencode(state, m.parentId)
    if (m.authorChannelKey) c.string.preencode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags =
      (m.parentId ? 1 : 0) |
      (m.authorChannelKey ? 2 : 0) |
      (m.publicBeeKey ? 4 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.text)
    c.uint.encode(state, flags)

    if (m.parentId) c.string.encode(state, m.parentId)
    if (m.authorChannelKey) c.string.encode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      text: r2,
      parentId: (flags & 1) !== 0 ? c.string.decode(state) : null,
      authorChannelKey: (flags & 2) !== 0 ? c.string.decode(state) : null,
      publicBeeKey: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/add-comment-response
const encoding113 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.commentId) c.string.preencode(state, m.commentId)
    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.commentId ? 2 : 0) |
      (m.queued ? 4 : 0) |
      (m.error ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.commentId) c.string.encode(state, m.commentId)
    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      commentId: (flags & 2) !== 0 ? c.string.decode(state) : null,
      queued: (flags & 4) !== 0,
      error: (flags & 8) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/list-comments-request
const encoding114 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 4 so always one byte

    if (m.page) c.uint.preencode(state, m.page)
    if (m.limit) c.uint.preencode(state, m.limit)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags =
      (m.page ? 1 : 0) |
      (m.limit ? 2 : 0) |
      (m.publicBeeKey ? 4 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (m.page) c.uint.encode(state, m.page)
    if (m.limit) c.uint.encode(state, m.limit)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      page: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      limit: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      publicBeeKey: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/list-comments-response.comments
const encoding115_1 = c.array(c.frame(encoding111))

// @peartube/list-comments-response
const encoding115 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte
    encoding115_1.preencode(state, m.comments)

    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.error ? 2 : 0)

    c.uint.encode(state, flags)
    encoding115_1.encode(state, m.comments)

    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      comments: encoding115_1.decode(state),
      error: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/hide-comment-request
const encoding116 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    state.end++ // max flag is 1 so always one byte

    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags = m.publicBeeKey ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.uint.encode(state, flags)

    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      commentId: r2,
      publicBeeKey: (flags & 1) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/hide-comment-response
const encoding117 = encoding30

// @peartube/remove-comment-request
const encoding118 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    state.end++ // max flag is 2 so always one byte

    if (m.authorChannelKey) c.string.preencode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags =
      (m.authorChannelKey ? 1 : 0) |
      (m.publicBeeKey ? 2 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.uint.encode(state, flags)

    if (m.authorChannelKey) c.string.encode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      commentId: r2,
      authorChannelKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      publicBeeKey: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/remove-comment-response
const encoding119 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.queued ? 2 : 0) |
      (m.error ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      queued: (flags & 2) !== 0,
      error: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/reaction-count
const encoding120 = {
  preencode(state, m) {
    c.string.preencode(state, m.reactionType)
    c.uint.preencode(state, m.count)
  },
  encode(state, m) {
    c.string.encode(state, m.reactionType)
    c.uint.encode(state, m.count)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)

    return {
      reactionType: r0,
      count: r1
    }
  }
}

// @peartube/add-reaction-request
const encoding121 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.reactionType)
    state.end++ // max flag is 2 so always one byte

    if (m.authorChannelKey) c.string.preencode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags =
      (m.authorChannelKey ? 1 : 0) |
      (m.publicBeeKey ? 2 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.reactionType)
    c.uint.encode(state, flags)

    if (m.authorChannelKey) c.string.encode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const r2 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      reactionType: r2,
      authorChannelKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      publicBeeKey: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/add-reaction-response
const encoding122 = encoding119

// @peartube/remove-reaction-request
const encoding123 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 2 so always one byte

    if (m.authorChannelKey) c.string.preencode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.preencode(state, m.publicBeeKey)
  },
  encode(state, m) {
    const flags =
      (m.authorChannelKey ? 1 : 0) |
      (m.publicBeeKey ? 2 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (m.authorChannelKey) c.string.encode(state, m.authorChannelKey)
    if (m.publicBeeKey) c.string.encode(state, m.publicBeeKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      authorChannelKey: (flags & 1) !== 0 ? c.string.decode(state) : null,
      publicBeeKey: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/remove-reaction-response
const encoding124 = encoding119

// @peartube/get-reactions-request
const encoding125 = encoding123

// @peartube/get-reactions-response.counts
const encoding126_1 = c.array(c.frame(encoding120))

// @peartube/get-reactions-response
const encoding126 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte
    encoding126_1.preencode(state, m.counts)

    if (m.userReaction) c.string.preencode(state, m.userReaction)
    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.userReaction ? 2 : 0) |
      (m.error ? 4 : 0)

    c.uint.encode(state, flags)
    encoding126_1.encode(state, m.counts)

    if (m.userReaction) c.string.encode(state, m.userReaction)
    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      counts: encoding126_1.decode(state),
      userReaction: (flags & 2) !== 0 ? c.string.decode(state) : null,
      error: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/log-watch-event-request
const encoding127 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 4 so always one byte

    if (m.duration) c.uint.preencode(state, m.duration)
  },
  encode(state, m) {
    const flags =
      (m.duration ? 1 : 0) |
      (m.completed ? 2 : 0) |
      (m.share ? 4 : 0)

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (m.duration) c.uint.encode(state, m.duration)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      duration: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      completed: (flags & 2) !== 0,
      share: (flags & 4) !== 0
    }
  }
}

// @peartube/log-watch-event-response
const encoding128 = encoding30

// @peartube/recommendation
const encoding129 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 2 so always one byte

    if (m.score) c.string.preencode(state, m.score)
    if (m.reason) c.string.preencode(state, m.reason)
  },
  encode(state, m) {
    const flags =
      (m.score ? 1 : 0) |
      (m.reason ? 2 : 0)

    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (m.score) c.string.encode(state, m.score)
    if (m.reason) c.string.encode(state, m.reason)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      score: (flags & 1) !== 0 ? c.string.decode(state) : null,
      reason: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-recommendations-request
const encoding130 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    state.end++ // max flag is 1 so always one byte

    if (m.limit) c.uint.preencode(state, m.limit)
  },
  encode(state, m) {
    const flags = m.limit ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.uint.encode(state, flags)

    if (m.limit) c.uint.encode(state, m.limit)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      limit: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-recommendations-response.recommendations
const encoding131_1 = c.array(c.frame(encoding129))

// @peartube/get-recommendations-response
const encoding131 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte
    encoding131_1.preencode(state, m.recommendations)

    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.error ? 2 : 0)

    c.uint.encode(state, flags)
    encoding131_1.encode(state, m.recommendations)

    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      recommendations: encoding131_1.decode(state),
      error: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/get-video-recommendations-request
const encoding132 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.videoId)
    state.end++ // max flag is 1 so always one byte

    if (m.limit) c.uint.preencode(state, m.limit)
  },
  encode(state, m) {
    const flags = m.limit ? 1 : 0

    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.videoId)
    c.uint.encode(state, flags)

    if (m.limit) c.uint.encode(state, m.limit)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      channelKey: r0,
      videoId: r1,
      limit: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/get-video-recommendations-response.recommendations
const encoding133_1 = encoding131_1

// @peartube/get-video-recommendations-response
const encoding133 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte
    encoding133_1.preencode(state, m.recommendations)

    if (m.error) c.string.preencode(state, m.error)
  },
  encode(state, m) {
    const flags =
      (m.success ? 1 : 0) |
      (m.error ? 2 : 0)

    c.uint.encode(state, flags)
    encoding133_1.encode(state, m.recommendations)

    if (m.error) c.string.encode(state, m.error)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      success: (flags & 1) !== 0,
      recommendations: encoding133_1.decode(state),
      error: (flags & 2) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/event-ready
const encoding134 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (m.blobServerPort) c.uint.preencode(state, m.blobServerPort)
  },
  encode(state, m) {
    const flags = m.blobServerPort ? 1 : 0

    c.uint.encode(state, flags)

    if (m.blobServerPort) c.uint.encode(state, m.blobServerPort)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      blobServerPort: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-error
const encoding135 = encoding1

// @peartube/event-upload-progress
const encoding136 = {
  preencode(state, m) {
    c.string.preencode(state, m.videoId)
    c.uint.preencode(state, m.progress)
    state.end++ // max flag is 8 so always one byte

    if (m.bytesUploaded) c.uint.preencode(state, m.bytesUploaded)
    if (m.totalBytes) c.uint.preencode(state, m.totalBytes)
    if (m.speed) c.uint.preencode(state, m.speed)
    if (m.eta) c.uint.preencode(state, m.eta)
  },
  encode(state, m) {
    const flags =
      (m.bytesUploaded ? 1 : 0) |
      (m.totalBytes ? 2 : 0) |
      (m.speed ? 4 : 0) |
      (m.eta ? 8 : 0)

    c.string.encode(state, m.videoId)
    c.uint.encode(state, m.progress)
    c.uint.encode(state, flags)

    if (m.bytesUploaded) c.uint.encode(state, m.bytesUploaded)
    if (m.totalBytes) c.uint.encode(state, m.totalBytes)
    if (m.speed) c.uint.encode(state, m.speed)
    if (m.eta) c.uint.encode(state, m.eta)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      videoId: r0,
      progress: r1,
      bytesUploaded: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      totalBytes: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      speed: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      eta: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-feed-update
const encoding137 = {
  preencode(state, m) {
    c.string.preencode(state, m.channelKey)
    c.string.preencode(state, m.action)
  },
  encode(state, m) {
    c.string.encode(state, m.channelKey)
    c.string.encode(state, m.action)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)

    return {
      channelKey: r0,
      action: r1
    }
  }
}

// @peartube/event-log
const encoding138 = {
  preencode(state, m) {
    c.string.preencode(state, m.level)
    c.string.preencode(state, m.message)
    state.end++ // max flag is 1 so always one byte

    if (m.timestamp) c.uint.preencode(state, m.timestamp)
  },
  encode(state, m) {
    const flags = m.timestamp ? 1 : 0

    c.string.encode(state, m.level)
    c.string.encode(state, m.message)
    c.uint.encode(state, flags)

    if (m.timestamp) c.uint.encode(state, m.timestamp)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      level: r0,
      message: r1,
      timestamp: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/event-video-stats.stats
const encoding139_0 = encoding61_0

// @peartube/event-video-stats
const encoding139 = {
  preencode(state, m) {
    encoding139_0.preencode(state, m.stats)
  },
  encode(state, m) {
    encoding139_0.encode(state, m.stats)
  },
  decode(state) {
    const r0 = encoding139_0.decode(state)

    return {
      stats: r0
    }
  }
}

// @peartube/channel-op-base
const encoding140 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
  },
  encode(state, m) {
    const flags = m.schemaVersion ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-update-channel
const encoding141 = {
  preencode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.key ? 2 : 0) |
      (m.name ? 4 : 0) |
      (m.description ? 8 : 0) |
      (m.avatar ? 16 : 0) |
      (m.updatedAt ? 32 : 0) |
      (m.updatedBy ? 64 : 0) |
      (m.createdAt ? 128 : 0) |
      (m.createdBy ? 256 : 0)

    c.string.preencode(state, m.type)
    c.uint.preencode(state, flags)

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    if (m.key) c.string.preencode(state, m.key)
    if (m.name) c.string.preencode(state, m.name)
    if (m.description) c.string.preencode(state, m.description)
    if (m.avatar) c.string.preencode(state, m.avatar)
    if (m.updatedAt) c.uint.preencode(state, m.updatedAt)
    if (m.updatedBy) c.string.preencode(state, m.updatedBy)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
    if (m.createdBy) c.string.preencode(state, m.createdBy)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.key ? 2 : 0) |
      (m.name ? 4 : 0) |
      (m.description ? 8 : 0) |
      (m.avatar ? 16 : 0) |
      (m.updatedAt ? 32 : 0) |
      (m.updatedBy ? 64 : 0) |
      (m.createdAt ? 128 : 0) |
      (m.createdBy ? 256 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    if (m.key) c.string.encode(state, m.key)
    if (m.name) c.string.encode(state, m.name)
    if (m.description) c.string.encode(state, m.description)
    if (m.avatar) c.string.encode(state, m.avatar)
    if (m.updatedAt) c.uint.encode(state, m.updatedAt)
    if (m.updatedBy) c.string.encode(state, m.updatedBy)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
    if (m.createdBy) c.string.encode(state, m.createdBy)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      key: (flags & 2) !== 0 ? c.string.decode(state) : null,
      name: (flags & 4) !== 0 ? c.string.decode(state) : null,
      description: (flags & 8) !== 0 ? c.string.decode(state) : null,
      avatar: (flags & 16) !== 0 ? c.string.decode(state) : null,
      updatedAt: (flags & 32) !== 0 ? c.uint.decode(state) : 0,
      updatedBy: (flags & 64) !== 0 ? c.string.decode(state) : null,
      createdAt: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      createdBy: (flags & 256) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-add-video
const encoding142 = {
  preencode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.path ? 4 : 0) |
      (m.duration ? 8 : 0) |
      (m.thumbnail ? 16 : 0) |
      (m.blobDriveKey ? 32 : 0) |
      (m.mimeType ? 64 : 0) |
      (m.size ? 128 : 0) |
      (m.uploadedAt ? 256 : 0) |
      (m.uploadedBy ? 512 : 0) |
      (m.category ? 1024 : 0) |
      (m.views ? 2048 : 0)

    c.string.preencode(state, m.type)
    c.uint.preencode(state, flags)

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.id)
    c.string.preencode(state, m.title)
    if (m.description) c.string.preencode(state, m.description)
    if (m.path) c.string.preencode(state, m.path)
    if (m.duration) c.uint.preencode(state, m.duration)
    if (m.thumbnail) c.string.preencode(state, m.thumbnail)
    if (m.blobDriveKey) c.string.preencode(state, m.blobDriveKey)
    if (m.mimeType) c.string.preencode(state, m.mimeType)
    if (m.size) c.uint.preencode(state, m.size)
    if (m.uploadedAt) c.uint.preencode(state, m.uploadedAt)
    if (m.uploadedBy) c.string.preencode(state, m.uploadedBy)
    if (m.category) c.string.preencode(state, m.category)
    if (m.views) c.uint.preencode(state, m.views)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.description ? 2 : 0) |
      (m.path ? 4 : 0) |
      (m.duration ? 8 : 0) |
      (m.thumbnail ? 16 : 0) |
      (m.blobDriveKey ? 32 : 0) |
      (m.mimeType ? 64 : 0) |
      (m.size ? 128 : 0) |
      (m.uploadedAt ? 256 : 0) |
      (m.uploadedBy ? 512 : 0) |
      (m.category ? 1024 : 0) |
      (m.views ? 2048 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.id)
    c.string.encode(state, m.title)
    if (m.description) c.string.encode(state, m.description)
    if (m.path) c.string.encode(state, m.path)
    if (m.duration) c.uint.encode(state, m.duration)
    if (m.thumbnail) c.string.encode(state, m.thumbnail)
    if (m.blobDriveKey) c.string.encode(state, m.blobDriveKey)
    if (m.mimeType) c.string.encode(state, m.mimeType)
    if (m.size) c.uint.encode(state, m.size)
    if (m.uploadedAt) c.uint.encode(state, m.uploadedAt)
    if (m.uploadedBy) c.string.encode(state, m.uploadedBy)
    if (m.category) c.string.encode(state, m.category)
    if (m.views) c.uint.encode(state, m.views)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      id: c.string.decode(state),
      title: c.string.decode(state),
      description: (flags & 2) !== 0 ? c.string.decode(state) : null,
      path: (flags & 4) !== 0 ? c.string.decode(state) : null,
      duration: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      thumbnail: (flags & 16) !== 0 ? c.string.decode(state) : null,
      blobDriveKey: (flags & 32) !== 0 ? c.string.decode(state) : null,
      mimeType: (flags & 64) !== 0 ? c.string.decode(state) : null,
      size: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      uploadedAt: (flags & 256) !== 0 ? c.uint.decode(state) : 0,
      uploadedBy: (flags & 512) !== 0 ? c.string.decode(state) : null,
      category: (flags & 1024) !== 0 ? c.string.decode(state) : null,
      views: (flags & 2048) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-update-video
const encoding143 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 64 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.id)
    if (m.title) c.string.preencode(state, m.title)
    if (m.description) c.string.preencode(state, m.description)
    if (m.thumbnail) c.string.preencode(state, m.thumbnail)
    if (m.category) c.string.preencode(state, m.category)
    if (m.updatedAt) c.uint.preencode(state, m.updatedAt)
    if (m.updatedBy) c.string.preencode(state, m.updatedBy)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.title ? 2 : 0) |
      (m.description ? 4 : 0) |
      (m.thumbnail ? 8 : 0) |
      (m.category ? 16 : 0) |
      (m.updatedAt ? 32 : 0) |
      (m.updatedBy ? 64 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.id)
    if (m.title) c.string.encode(state, m.title)
    if (m.description) c.string.encode(state, m.description)
    if (m.thumbnail) c.string.encode(state, m.thumbnail)
    if (m.category) c.string.encode(state, m.category)
    if (m.updatedAt) c.uint.encode(state, m.updatedAt)
    if (m.updatedBy) c.string.encode(state, m.updatedBy)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      id: c.string.decode(state),
      title: (flags & 2) !== 0 ? c.string.decode(state) : null,
      description: (flags & 4) !== 0 ? c.string.decode(state) : null,
      thumbnail: (flags & 8) !== 0 ? c.string.decode(state) : null,
      category: (flags & 16) !== 0 ? c.string.decode(state) : null,
      updatedAt: (flags & 32) !== 0 ? c.uint.decode(state) : 0,
      updatedBy: (flags & 64) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-delete-video
const encoding144 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.id)
  },
  encode(state, m) {
    const flags = m.schemaVersion ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.id)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      id: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-add-writer
const encoding145 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 16 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.keyHex)
    if (m.role) c.string.preencode(state, m.role)
    if (m.deviceName) c.string.preencode(state, m.deviceName)
    if (m.addedAt) c.uint.preencode(state, m.addedAt)
    if (m.blobDriveKey) c.string.preencode(state, m.blobDriveKey)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.role ? 2 : 0) |
      (m.deviceName ? 4 : 0) |
      (m.addedAt ? 8 : 0) |
      (m.blobDriveKey ? 16 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.keyHex)
    if (m.role) c.string.encode(state, m.role)
    if (m.deviceName) c.string.encode(state, m.deviceName)
    if (m.addedAt) c.uint.encode(state, m.addedAt)
    if (m.blobDriveKey) c.string.encode(state, m.blobDriveKey)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      keyHex: c.string.decode(state),
      role: (flags & 2) !== 0 ? c.string.decode(state) : null,
      deviceName: (flags & 4) !== 0 ? c.string.decode(state) : null,
      addedAt: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      blobDriveKey: (flags & 16) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-upsert-writer
const encoding146 = encoding145

// @peartube/channel-op-remove-writer
const encoding147 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 2 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.keyHex)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.ban ? 2 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.keyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      keyHex: c.string.decode(state),
      ban: (flags & 2) !== 0
    }
  }
}

// @peartube/channel-op-add-invite
const encoding148 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 8 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.idHex)
    c.string.preencode(state, m.inviteZ32)
    if (m.publicKeyHex) c.string.preencode(state, m.publicKeyHex)
    if (m.expires) c.uint.preencode(state, m.expires)
    if (m.createdAt) c.uint.preencode(state, m.createdAt)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.publicKeyHex ? 2 : 0) |
      (m.expires ? 4 : 0) |
      (m.createdAt ? 8 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.idHex)
    c.string.encode(state, m.inviteZ32)
    if (m.publicKeyHex) c.string.encode(state, m.publicKeyHex)
    if (m.expires) c.uint.encode(state, m.expires)
    if (m.createdAt) c.uint.encode(state, m.createdAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      idHex: c.string.decode(state),
      inviteZ32: c.string.decode(state),
      publicKeyHex: (flags & 2) !== 0 ? c.string.decode(state) : null,
      expires: (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      createdAt: (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-delete-invite
const encoding149 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.idHex)
  },
  encode(state, m) {
    const flags = m.schemaVersion ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.idHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      idHex: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-add-comment
const encoding150 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 4 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    c.string.preencode(state, m.text)
    c.string.preencode(state, m.authorKeyHex)
    if (m.timestamp) c.uint.preencode(state, m.timestamp)
    if (m.parentId) c.string.preencode(state, m.parentId)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.timestamp ? 2 : 0) |
      (m.parentId ? 4 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.string.encode(state, m.text)
    c.string.encode(state, m.authorKeyHex)
    if (m.timestamp) c.uint.encode(state, m.timestamp)
    if (m.parentId) c.string.encode(state, m.parentId)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      commentId: c.string.decode(state),
      text: c.string.decode(state),
      authorKeyHex: c.string.decode(state),
      timestamp: (flags & 2) !== 0 ? c.uint.decode(state) : 0,
      parentId: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-add-reaction
const encoding151 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 2 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.reactionType)
    c.string.preencode(state, m.authorKeyHex)
    if (m.timestamp) c.uint.preencode(state, m.timestamp)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.timestamp ? 2 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.reactionType)
    c.string.encode(state, m.authorKeyHex)
    if (m.timestamp) c.uint.encode(state, m.timestamp)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      reactionType: c.string.decode(state),
      authorKeyHex: c.string.decode(state),
      timestamp: (flags & 2) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-remove-reaction
const encoding152 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.authorKeyHex)
  },
  encode(state, m) {
    const flags = m.schemaVersion ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.authorKeyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      authorKeyHex: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-hide-comment
const encoding153 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 1 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    c.string.preencode(state, m.moderatorKeyHex)
  },
  encode(state, m) {
    const flags = m.schemaVersion ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    c.string.encode(state, m.moderatorKeyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      commentId: c.string.decode(state),
      moderatorKeyHex: c.string.decode(state)
    }
  }
}

// @peartube/channel-op-remove-comment
const encoding154 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 4 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    c.string.preencode(state, m.commentId)
    if (m.moderatorKeyHex) c.string.preencode(state, m.moderatorKeyHex)
    if (m.authorKeyHex) c.string.preencode(state, m.authorKeyHex)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.moderatorKeyHex ? 2 : 0) |
      (m.authorKeyHex ? 4 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    c.string.encode(state, m.commentId)
    if (m.moderatorKeyHex) c.string.encode(state, m.moderatorKeyHex)
    if (m.authorKeyHex) c.string.encode(state, m.authorKeyHex)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      commentId: c.string.decode(state),
      moderatorKeyHex: (flags & 2) !== 0 ? c.string.decode(state) : null,
      authorKeyHex: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-add-vector-index
const encoding155 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 8 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    if (m.vector) c.string.preencode(state, m.vector)
    if (m.text) c.string.preencode(state, m.text)
    if (m.metadata) c.string.preencode(state, m.metadata)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.vector ? 2 : 0) |
      (m.text ? 4 : 0) |
      (m.metadata ? 8 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    if (m.vector) c.string.encode(state, m.vector)
    if (m.text) c.string.encode(state, m.text)
    if (m.metadata) c.string.encode(state, m.metadata)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      vector: (flags & 2) !== 0 ? c.string.decode(state) : null,
      text: (flags & 4) !== 0 ? c.string.decode(state) : null,
      metadata: (flags & 8) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @peartube/channel-op-log-watch-event
const encoding156 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    state.end++ // max flag is 32 so always one byte

    if (m.schemaVersion) c.uint.preencode(state, m.schemaVersion)
    c.string.preencode(state, m.videoId)
    if (m.channelKey) c.string.preencode(state, m.channelKey)
    if (m.watcherKeyHex) c.string.preencode(state, m.watcherKeyHex)
    if (m.duration) c.uint.preencode(state, m.duration)
    if (m.timestamp) c.uint.preencode(state, m.timestamp)
  },
  encode(state, m) {
    const flags =
      (m.schemaVersion ? 1 : 0) |
      (m.channelKey ? 2 : 0) |
      (m.watcherKeyHex ? 4 : 0) |
      (m.duration ? 8 : 0) |
      (m.completed ? 16 : 0) |
      (m.timestamp ? 32 : 0)

    c.string.encode(state, m.type)
    c.uint.encode(state, flags)

    if (m.schemaVersion) c.uint.encode(state, m.schemaVersion)
    c.string.encode(state, m.videoId)
    if (m.channelKey) c.string.encode(state, m.channelKey)
    if (m.watcherKeyHex) c.string.encode(state, m.watcherKeyHex)
    if (m.duration) c.uint.encode(state, m.duration)
    if (m.timestamp) c.uint.encode(state, m.timestamp)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: (flags & 1) !== 0 ? c.uint.decode(state) : 0,
      videoId: c.string.decode(state),
      channelKey: (flags & 2) !== 0 ? c.string.decode(state) : null,
      watcherKeyHex: (flags & 4) !== 0 ? c.string.decode(state) : null,
      duration: (flags & 8) !== 0 ? c.uint.decode(state) : 0,
      completed: (flags & 16) !== 0,
      timestamp: (flags & 32) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @peartube/channel-op-migrate-schema
const encoding157 = {
  preencode(state, m) {
    c.string.preencode(state, m.type)
    c.uint.preencode(state, m.schemaVersion)
    c.uint.preencode(state, m.fromVersion)
    c.uint.preencode(state, m.toVersion)
    state.end++ // max flag is 1 so always one byte

    if (m.migratedAt) c.uint.preencode(state, m.migratedAt)
  },
  encode(state, m) {
    const flags = m.migratedAt ? 1 : 0

    c.string.encode(state, m.type)
    c.uint.encode(state, m.schemaVersion)
    c.uint.encode(state, m.fromVersion)
    c.uint.encode(state, m.toVersion)
    c.uint.encode(state, flags)

    if (m.migratedAt) c.uint.encode(state, m.migratedAt)
  },
  decode(state) {
    const r0 = c.string.decode(state)
    const r1 = c.uint.decode(state)
    const r2 = c.uint.decode(state)
    const r3 = c.uint.decode(state)
    const flags = c.uint.decode(state)

    return {
      type: r0,
      schemaVersion: r1,
      fromVersion: r2,
      toVersion: r3,
      migratedAt: (flags & 1) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

function setVersion(v) {
  version = v
}

function encode(name, value, v = VERSION) {
  version = v
  return c.encode(getEncoding(name), value)
}

function decode(name, buffer, v = VERSION) {
  version = v
  return c.decode(getEncoding(name), buffer)
}

function getEnum(name) {
  switch (name) {
    default:
      throw new Error('Enum not found ' + name)
  }
}

function getEncoding(name) {
  switch (name) {
    case '@peartube/empty':
      return encoding0
    case '@peartube/error':
      return encoding1
    case '@peartube/identity':
      return encoding2
    case '@peartube/create-identity-request':
      return encoding3
    case '@peartube/create-identity-response':
      return encoding4
    case '@peartube/get-identity-request':
      return encoding5
    case '@peartube/get-identity-response':
      return encoding6
    case '@peartube/get-identities-request':
      return encoding7
    case '@peartube/get-identities-response':
      return encoding8
    case '@peartube/set-active-identity-request':
      return encoding9
    case '@peartube/set-active-identity-response':
      return encoding10
    case '@peartube/recover-identity-request':
      return encoding11
    case '@peartube/recover-identity-response':
      return encoding12
    case '@peartube/channel':
      return encoding13
    case '@peartube/get-channel-request':
      return encoding14
    case '@peartube/get-channel-response':
      return encoding15
    case '@peartube/update-channel-request':
      return encoding16
    case '@peartube/update-channel-response':
      return encoding17
    case '@peartube/video':
      return encoding18
    case '@peartube/list-videos-request':
      return encoding19
    case '@peartube/list-videos-response':
      return encoding20
    case '@peartube/get-video-url-request':
      return encoding21
    case '@peartube/get-video-url-response':
      return encoding22
    case '@peartube/get-video-data-request':
      return encoding23
    case '@peartube/get-video-data-response':
      return encoding24
    case '@peartube/upload-video-request':
      return encoding25
    case '@peartube/upload-video-response':
      return encoding26
    case '@peartube/download-video-request':
      return encoding27
    case '@peartube/download-video-response':
      return encoding28
    case '@peartube/delete-video-request':
      return encoding29
    case '@peartube/delete-video-response':
      return encoding30
    case '@peartube/subscription':
      return encoding31
    case '@peartube/subscribe-channel-request':
      return encoding32
    case '@peartube/subscribe-channel-response':
      return encoding33
    case '@peartube/unsubscribe-channel-request':
      return encoding34
    case '@peartube/unsubscribe-channel-response':
      return encoding35
    case '@peartube/get-subscriptions-request':
      return encoding36
    case '@peartube/get-subscriptions-response':
      return encoding37
    case '@peartube/join-channel-request':
      return encoding38
    case '@peartube/join-channel-response':
      return encoding39
    case '@peartube/feed-entry':
      return encoding40
    case '@peartube/get-public-feed-request':
      return encoding41
    case '@peartube/get-public-feed-response':
      return encoding42
    case '@peartube/refresh-feed-request':
      return encoding43
    case '@peartube/refresh-feed-response':
      return encoding44
    case '@peartube/submit-to-feed-request':
      return encoding45
    case '@peartube/submit-to-feed-response':
      return encoding46
    case '@peartube/unpublish-from-feed-request':
      return encoding47
    case '@peartube/unpublish-from-feed-response':
      return encoding48
    case '@peartube/is-channel-published-request':
      return encoding49
    case '@peartube/is-channel-published-response':
      return encoding50
    case '@peartube/hide-channel-request':
      return encoding51
    case '@peartube/hide-channel-response':
      return encoding52
    case '@peartube/get-channel-meta-request':
      return encoding53
    case '@peartube/get-channel-meta-response':
      return encoding54
    case '@peartube/get-swarm-status-request':
      return encoding55
    case '@peartube/get-swarm-status-response':
      return encoding56
    case '@peartube/prefetch-video-request':
      return encoding57
    case '@peartube/prefetch-video-response':
      return encoding58
    case '@peartube/video-stats':
      return encoding59
    case '@peartube/get-video-stats-request':
      return encoding60
    case '@peartube/get-video-stats-response':
      return encoding61
    case '@peartube/seeding-config':
      return encoding62
    case '@peartube/seeding-status':
      return encoding63
    case '@peartube/get-seeding-status-request':
      return encoding64
    case '@peartube/get-seeding-status-response':
      return encoding65
    case '@peartube/set-seeding-config-request':
      return encoding66
    case '@peartube/set-seeding-config-response':
      return encoding67
    case '@peartube/pin-channel-request':
      return encoding68
    case '@peartube/pin-channel-response':
      return encoding69
    case '@peartube/unpin-channel-request':
      return encoding70
    case '@peartube/unpin-channel-response':
      return encoding71
    case '@peartube/get-pinned-channels-request':
      return encoding72
    case '@peartube/get-pinned-channels-response':
      return encoding73
    case '@peartube/get-storage-stats-request':
      return encoding74
    case '@peartube/get-storage-stats-response':
      return encoding75
    case '@peartube/set-storage-limit-request':
      return encoding76
    case '@peartube/set-storage-limit-response':
      return encoding77
    case '@peartube/clear-cache-request':
      return encoding78
    case '@peartube/clear-cache-response':
      return encoding79
    case '@peartube/get-video-thumbnail-request':
      return encoding80
    case '@peartube/get-video-thumbnail-response':
      return encoding81
    case '@peartube/get-video-metadata-request':
      return encoding82
    case '@peartube/get-video-metadata-response':
      return encoding83
    case '@peartube/set-video-thumbnail-request':
      return encoding84
    case '@peartube/set-video-thumbnail-from-file-request':
      return encoding85
    case '@peartube/set-video-thumbnail-from-file-response':
      return encoding86
    case '@peartube/set-video-thumbnail-response':
      return encoding87
    case '@peartube/status':
      return encoding88
    case '@peartube/get-status-request':
      return encoding89
    case '@peartube/get-status-response':
      return encoding90
    case '@peartube/pick-video-file-request':
      return encoding91
    case '@peartube/pick-video-file-response':
      return encoding92
    case '@peartube/pick-image-file-request':
      return encoding93
    case '@peartube/pick-image-file-response':
      return encoding94
    case '@peartube/get-blob-server-port-request':
      return encoding95
    case '@peartube/get-blob-server-port-response':
      return encoding96
    case '@peartube/device':
      return encoding97
    case '@peartube/create-device-invite-request':
      return encoding98
    case '@peartube/create-device-invite-response':
      return encoding99
    case '@peartube/pair-device-request':
      return encoding100
    case '@peartube/pair-device-response':
      return encoding101
    case '@peartube/retry-sync-channel-request':
      return encoding102
    case '@peartube/retry-sync-channel-response':
      return encoding103
    case '@peartube/list-devices-request':
      return encoding104
    case '@peartube/list-devices-response':
      return encoding105
    case '@peartube/search-result':
      return encoding106
    case '@peartube/search-videos-request':
      return encoding107
    case '@peartube/search-videos-response':
      return encoding108
    case '@peartube/index-video-vectors-request':
      return encoding109
    case '@peartube/index-video-vectors-response':
      return encoding110
    case '@peartube/comment':
      return encoding111
    case '@peartube/add-comment-request':
      return encoding112
    case '@peartube/add-comment-response':
      return encoding113
    case '@peartube/list-comments-request':
      return encoding114
    case '@peartube/list-comments-response':
      return encoding115
    case '@peartube/hide-comment-request':
      return encoding116
    case '@peartube/hide-comment-response':
      return encoding117
    case '@peartube/remove-comment-request':
      return encoding118
    case '@peartube/remove-comment-response':
      return encoding119
    case '@peartube/reaction-count':
      return encoding120
    case '@peartube/add-reaction-request':
      return encoding121
    case '@peartube/add-reaction-response':
      return encoding122
    case '@peartube/remove-reaction-request':
      return encoding123
    case '@peartube/remove-reaction-response':
      return encoding124
    case '@peartube/get-reactions-request':
      return encoding125
    case '@peartube/get-reactions-response':
      return encoding126
    case '@peartube/log-watch-event-request':
      return encoding127
    case '@peartube/log-watch-event-response':
      return encoding128
    case '@peartube/recommendation':
      return encoding129
    case '@peartube/get-recommendations-request':
      return encoding130
    case '@peartube/get-recommendations-response':
      return encoding131
    case '@peartube/get-video-recommendations-request':
      return encoding132
    case '@peartube/get-video-recommendations-response':
      return encoding133
    case '@peartube/event-ready':
      return encoding134
    case '@peartube/event-error':
      return encoding135
    case '@peartube/event-upload-progress':
      return encoding136
    case '@peartube/event-feed-update':
      return encoding137
    case '@peartube/event-log':
      return encoding138
    case '@peartube/event-video-stats':
      return encoding139
    case '@peartube/channel-op-base':
      return encoding140
    case '@peartube/channel-op-update-channel':
      return encoding141
    case '@peartube/channel-op-add-video':
      return encoding142
    case '@peartube/channel-op-update-video':
      return encoding143
    case '@peartube/channel-op-delete-video':
      return encoding144
    case '@peartube/channel-op-add-writer':
      return encoding145
    case '@peartube/channel-op-upsert-writer':
      return encoding146
    case '@peartube/channel-op-remove-writer':
      return encoding147
    case '@peartube/channel-op-add-invite':
      return encoding148
    case '@peartube/channel-op-delete-invite':
      return encoding149
    case '@peartube/channel-op-add-comment':
      return encoding150
    case '@peartube/channel-op-add-reaction':
      return encoding151
    case '@peartube/channel-op-remove-reaction':
      return encoding152
    case '@peartube/channel-op-hide-comment':
      return encoding153
    case '@peartube/channel-op-remove-comment':
      return encoding154
    case '@peartube/channel-op-add-vector-index':
      return encoding155
    case '@peartube/channel-op-log-watch-event':
      return encoding156
    case '@peartube/channel-op-migrate-schema':
      return encoding157
    default:
      throw new Error('Encoder not found ' + name)
  }
}

function getStruct(name, v = VERSION) {
  const enc = getEncoding(name)
  return {
    preencode(state, m) {
      version = v
      enc.preencode(state, m)
    },
    encode(state, m) {
      version = v
      enc.encode(state, m)
    },
    decode(state) {
      version = v
      return enc.decode(state)
    }
  }
}

const resolveStruct = getStruct // compat

module.exports = {
  resolveStruct,
  getStruct,
  getEnum,
  getEncoding,
  encode,
  decode,
  setVersion,
  version,
  VERSION
}
